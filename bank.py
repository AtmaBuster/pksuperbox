# ~ 18: Fairy
# ~ 19: Wind
# ~ 20: Abnormal
# ~ 21: Sound
# ~ 22: Gas
# ~ 23: Wood
# ~ 24: Tri

import pyperclip

import pygame, threading, math, webbrowser
import zlib, json, random, os, os.path, re, time
import poke, save, argparse
import pokedb, gamedb, textdb, by
import tkinter as tk
from tkinter import filedialog
import creditsdata as cred

class Container: pass

# (frame delay, chars per write)
# effectively does [1] / [0] chars-per-frame
# if [0] == 0, it is instant
TEXT_SPEEDS = ((0, 0),(1, 5),(1, 3),(1, 1),(3, 1),(5, 1),(7, 1),(9, 1))
class Globals:
	def __init__(self):
		self.text_speed_ind = 4
		self.window_frame = 0
		self.frame_ct = 0

		self.muted = False
		self.vol_master = 1.0
		self.vol_music = 1.0
		self.vol_sfx = 1.0

		self.language = 0

		self.fullscreen = False
		self.fullscreen_size = None

		self.use_shiny_particles = True

		self.font = None
		self.window_frames_surf = None
		self.empty_window_frame_tile = pygame.Surface((8, 8))
		self.empty_window_frame_tile.fill(pygame.Color((248, 248, 248)))

		self.missing_asset = pygame.image.load('assets/image/missing.png')
		self.hover_box_tiles = pygame.image.load('assets/image/hover_box_tiles.png')
		self.game_icons = pygame.image.load('assets/image/game_icons.png')

		self.show_hidden_button_rects = False

	def get_mus_volume(self):
		if self.muted:
			return 0.0
		return self.vol_master * self.vol_music

	@property
	def text_speed(self):
		ind = min(max(self.text_speed_ind, 0), len(TEXT_SPEEDS) - 1)
		return TEXT_SPEEDS[len(TEXT_SPEEDS) - ind - 1]

	def get_window_frame_tile(self, i):
		if i == 4: return self.empty_window_frame_tile
		x = i * 8
		if i > 4: x -= 8
		y = self.window_frame * 8
		return self.window_frames_surf.subsurface(pygame.Rect(x, y, 8, 8))

	def get_game_icon(self, i):
		setsizew = self.game_icons.get_rect().size[0] // 32
		x = i % setsizew
		y = i // setsizew
		return self.game_icons.subsurface(pygame.Rect(x*32, y*32, 32, 32))

	def change_text_speed(self, diff):
		self.text_speed_ind = min(max(self.text_speed_ind + diff, 0), len(TEXT_SPEEDS) - 1)
	def set_window_frame(self, val, game_obj):
		frm_x = val
		frm_y = game_obj['frame_row']
		self.window_frame = frm_y * 5 + frm_x

GL = Globals()

def read_file(fn, isbin=False):
	mode = 'r'
	if isbin:
		mode = 'rb'
	try:
		f = open(fn, mode)
	except FileNotFoundError:
		return None
	return f.read()

def write_file(fn, dat, isbin=False):
	mode = 'w'
	if isbin:
		mode = 'wb'
	directory = os.path.dirname(fn)
	if directory == '':
		directory = '.'
	if not os.path.exists(directory):
		os.makedirs(directory)
	open(fn, mode).write(dat)

HOVER_BOX_COLORS = (pygame.Color(  0, 248, 152),pygame.Color(  0, 200, 184),pygame.Color(234, 232, 224),pygame.Color(248, 248, 248))
HOVER_BOX_VCOL = (0, 0, 2, 3, 3)
HOVER_BOX_HCOL = (0, 0, 1, 1, 1, 1, 2, 3, 3, 3)
def make_hover_box(txt):
	txt_s = GL.font.render_text(txt, 16, TXT_COL_DARK)
	siz = txt_s.get_rect().size
	w = siz[0] + 20
	h = siz[1] + 10
	s_out = pygame.Surface((w, h), pygame.SRCALPHA)
	for y,ci in enumerate(HOVER_BOX_VCOL):
		pygame.draw.line(s_out, HOVER_BOX_COLORS[ci], (10, y), (w-10, y))
		pygame.draw.line(s_out, HOVER_BOX_COLORS[ci], (10, h-y-1), (w-10, h-y-1))
	for x,ci in enumerate(HOVER_BOX_HCOL):
		pygame.draw.line(s_out, HOVER_BOX_COLORS[ci], (x, 5), (x, h-5))
		pygame.draw.line(s_out, HOVER_BOX_COLORS[ci], (w-x-1, 5), (w-x-1, h-5))
	s_out.blit(GL.hover_box_tiles, (0, 0), pygame.Rect( 0, 0, 10, 5))
	s_out.blit(GL.hover_box_tiles, (w-10, 0), pygame.Rect(10, 0, 10, 5))
	s_out.blit(GL.hover_box_tiles, (0, h-5), pygame.Rect( 0, 5, 10, 5))
	s_out.blit(GL.hover_box_tiles, (w-10, h-5), pygame.Rect(10, 5, 10, 5))
	s_out.fill(HOVER_BOX_COLORS[3], pygame.Rect(10, 5, w-20, h-10))
	s_out.blit(txt_s, (10, 5))
	return s_out

def make_game_button_surf(crc):
	s_out = pygame.Surface((188, 32), pygame.SRCALPHA)
	game_hdr = gamedb.GAME_CRC[crc]
	game_dat = gamedb.GAME_DATA[game_hdr[0]]
	nam = game_hdr[3]
	ico_i = game_hdr[4]
	gen = game_dat['gen']

	s_out.blit(GL.get_game_icon(ico_i), (0, 0))
	s_out.blit(GL.font.render_line_trunc(nam, 152, TXT_COL_DARK), (36, 0))
	s_out.blit(GL.font.render_line(f'Gen {gen}', TXT_COL_DARK), (36, 16))
	if game_dat['is_hack']:
		s_out.blit(GL.font.render_line('ROM Hack', TXT_COL_DARK), (128, 16))
	return s_out

def get_screen_dim():
	try:
		root = tk.Tk()
		w = root.winfo_screenwidth()
		h = root.winfo_screenheight()
		root.destroy()
		root.quit()
		return (w, h)
	except:
		return (-1, -1)

def load_options():
	s = read_file('save/settings.json')
	if s is None:
		return
	d = json.loads(s)
	GL.text_speed_ind = d['text_speed']
	GL.window_frame = d['window_frame']
	GL.fullscreen = d['fullscreen']
	GL.muted = d['muted']
	GL.vol_master = d['vol'][0]
	GL.vol_music = d['vol'][1]
	GL.vol_sfx = d['vol'][2]
	GL.language = d['language']
	GL.use_shiny_particles = d['shiny_particle']

def save_options():
	d = {}
	d['text_speed'] = GL.text_speed_ind
	d['window_frame'] = GL.window_frame
	d['fullscreen'] = GL.fullscreen
	d['muted'] = GL.muted
	d['vol'] = [GL.vol_master, GL.vol_music, GL.vol_sfx]
	d['language'] = GL.language
	d['shiny_particle'] = GL.use_shiny_particles
	s = json.dumps(d, indent='\t')
	write_file('save/settings.json', s)

args = None

WIN_SIZE = (640, 360)
WIN_SCALE = 2
VIEW_SIZE = (WIN_SIZE[0] * WIN_SCALE, WIN_SIZE[1] * WIN_SCALE)

def update_view_size(scl):
	global VIEW_SIZE
	VIEW_SIZE = (WIN_SIZE[0] * scl, WIN_SIZE[1] * scl)

MOUSE_SCALE = WIN_SCALE
posscale = lambda x: (x[0] // MOUSE_SCALE, x[1] // MOUSE_SCALE)

TXT_COL_MONO  = 0
TXT_COL_DARK  = 1
TXT_COL_LIGHT = 2
TXT_COL_RED   = 3
TXT_COL_BLUE  = 4

TXT_COL_RGB = (
	((0, 0, 0), (255, 255, 255)),
	((96, 96, 96), (208, 208, 208)),
	((248, 248, 248), (96, 96, 96)),
	((248, 184, 112), (224, 8, 8)),
	((200, 168, 232), (48, 80, 200)),
)

SCENE_NONE    = 0
SCENE_TITLE   = 1
SCENE_BOX     = 2
SCENE_DEX     = 3
SCENE_LOAD    = 4
SCENE_OPTIONS = 5
SCENE_CREDITS = 6
SCENE_LAYOUTTEST = 999

MAX_PARTICLES = 1000

def cx_coords(rect, x):
	rect.centerx = x
	return rect.topleft

def rx_coords(rect, pos):
	rect.topright = pos
	return rect.topleft

def align_rect_center_x(r1, r2):
	# align r2's center-x to r1's center-x
	# return r2's top-left
	r2.centerx = r1.centerx
	return r2.topleft

class Font:
	char_width = (
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		3,2,0,0,0,8,6,3,3,3,0,0,3,6,3,6,
		7,4,7,7,7,7,7,7,7,7,3,3,8,8,4,6,
		0,6,6,6,6,6,6,6,6,4,6,6,6,6,6,6,
		6,6,6,6,6,6,6,6,6,6,6,3,6,3,0,0,
		0,6,6,6,6,6,5,6,6,2,4,6,3,6,6,6,
		6,6,6,6,5,6,6,6,6,6,6,7,0,8,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,
		0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,
		0,0,0,0,6,0,0,0,0,6,0,0,0,0,0,0,
		0,0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,
		6,6,6,4,4,6,6,5,8,3,6,6,5,5,8,0,
	)
	char_width_jpn = (
		8,10,8,10,8,9,8,10,8,10,10,10,10,10,10,10,
		10,10,10,10,10,10,8,9,10,10,10,10,10,10,10,10,
		10,10,8,10,9,10,10,8,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,8,10,8,10,8,10,10,8,10,10,10,0,10,0,
		0,0,10,10,0,0,0,0,0,0,0,0,0,0,0,0,
		8,10,8,9,8,10,8,10,8,10,10,10,10,10,10,10,
		10,10,9,9,10,10,10,10,10,10,10,10,9,9,10,10,
		10,10,8,10,10,10,10,9,9,10,10,10,10,9,10,10,
		10,9,10,10,10,10,10,10,10,10,10,10,10,10,9,10,
		8,10,8,10,8,10,7,9,10,9,10,9,10,0,10,0,
		0,10,10,0,0,0,0,0,0,0,0,9,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	)
	spc_id = {
		'“': 0x100,'”': 0x101,'…': 0x102,'‘': 0x103,
		'’': 0x104,'♂': 0x105,'♀': 0x106,
		'。':0x107,'ー':0x108,'・':0x109,'『':0x10A,
		'』':0x10B,'「':0x10C,'」':0x10D,
		'★':0x10E,
	}
	apost_map = {
		'·':'d','¸':'l','¹':'m','º':'r',
		'»':'s','¼':'t','½':'v',
	}
	char_rect = pygame.Rect((1, 1, 12, 12))
	def __init__(self):
		base_im = pygame.image.load('assets/image/font.png')
		self.ims = [base_im]
		for col_i in range(1, len(TXT_COL_RGB)):
			self.ims.append(self.make_color_font(base_im, TXT_COL_RGB[0], TXT_COL_RGB[col_i]))
		self.color = 0
		self.fw_nums = pygame.image.load('assets/image/dex/numfont.png')

	def get_fw_num(self, i, zpad=0):
		s = str(i).zfill(zpad)
		surf = pygame.Surface((5 * len(s), 10), pygame.SRCALPHA)
		for x,c in enumerate(s):
			ci = ord(c) - ord('0')
			surf.blit(self.fw_nums, (x * 5, 0), pygame.Rect(ci * 5, 0, 5, 10))
		return surf

	def get_dex_num_str(self, i, hck):
		i_s = self.get_fw_num(i, 3)
		n_s = self.render_line('No. ', TXT_COL_DARK)
		sz1 = i_s.get_rect().size
		sz2 = n_s.get_rect().size
		h = sz2[1]
		w = sz1[0] + sz2[0]
		if hck:
			w += self.cw('★')
			n_x = sz2[0] + self.cw('★')
		else:
			n_x = sz2[0]
		so = pygame.Surface((w, h), pygame.SRCALPHA)
		so.blit(n_s, (0, 0))
		so.blit(i_s, (n_x, 1))
		if hck:
			so.blit(self['★'], (sz2[0], 0))
		return so

	def make_color_font(self, base_im, col_in, col_out):
		col_map = dict(zip(col_in, col_out))
		im_out = base_im.copy()
		pxl = pygame.PixelArray(im_out)
		for k, v in col_map.items():
			pxl.replace(k, v)
		return im_out

	def __getitem__(self, c):
		ind = self.ci(c)
		if ind >= 0x1000:
			y = (ind - 0x1000) // 16
			x = (ind - 0x1000) % 16 + 16
		else:
			y = ind // 16
			x = ind % 16
		return self.ims[self.color].subsurface(self.char_rect.move(x * 13, y * 13))

	def getc(self, c, col):
		save_color = self.color
		self.color = col
		cs = self[c]
		self.color = save_color
		return cs

	def ci(self, c):
		if ord(c) >= 12353:
			return ord(c) - 12353 + 0x1000
		return self.spc_id.get(c, ord(c))

	def _cw(self, c):
		if c in self.apost_map.keys():
			c1 = '\''
			c2 = self.apost_map[c]
			return self.cw(c1) + self.cw(c2)
		ci = self.ci(c)
		if ci >= 0x1000:
			try:
				return self.char_width_jpn[ci - 0x1000] + 1
			except:
				print(c)
				return 0
		return self.char_width[ci]

	def cw(self, c):
		v = self._cw(c)
		# ~ if v == 0:
			# ~ print(c)
		return v

	def get_line_w(self, txt):
		w = 0
		for c in txt:
			w += self.cw(c)
		return w

	def set_color(self, col):
		self.color = col

	def render_line(self, txt, color=None):
		if not color is None:
			self.set_color(color)
		w = self.get_line_w(txt)
		s = pygame.Surface((w, 13), pygame.SRCALPHA)
		x = 0
		for c in txt:
			y = int(c == ',')
			if c in self.apost_map.keys():
				s.blit(self['\''], (x, y))
				x += self.cw('\'')
				l = self.apost_map[c]
				s.blit(self[l], (x, y))
				x += self.cw(l)
			else:
				s.blit(self[c], (x, y))
				x += self.cw(c)
		return s

	def render_line_trunc(self, txt, maxw, color=None):
		w = self.get_line_w(txt)
		if w <= maxw:
			return self.render_line(txt, color)
		elip_w = self.cw('…')
		new_txt = ''
		cur_w = 0
		for c in txt:
			new_c_w = self.cw(c)
			if cur_w + new_c_w > maxw - elip_w:
				break
			new_txt += c
			cur_w += new_c_w
		new_txt += '…'
		return self.render_line(new_txt, color)

	def render_text(self, txt, linesize, color=None):
		if not color is None:
			self.set_color(color)
		lins = txt.split('\n')
		maxw = max([self.get_line_w(l) for l in lins])
		surf_h = (len(lins) - 1) * linesize + 13
		surf = pygame.Surface((maxw, surf_h), pygame.SRCALPHA)
		for y,l in enumerate(lins):
			surf.blit(self.render_line(l), (0, y * linesize))
		return surf

	def auto_line_text(self, txt, maxw):
		words = txt.split(' ')
		words = [(w, self.get_line_w(w)) for w in words]
		lins = []
		curx = 0
		curlin = []
		for wrd, sz in words:
			if curx + sz > maxw and curx != 0:
				lins.append(' '.join(curlin))
				curx = 0
				curlin = []
			curlin.append(wrd)
			curx += sz + self.char_width[ord(' ')]
		if curx != 0:
			lins.append(' '.join(curlin))
		return '\n'.join(lins)

# python won't let me store these as actual integers REEEEEEE
SPINDA_SPOTS = (
int('0000000000001110000000000000000000000000000000000000000000000000'+'0000000000111111100000000000000000000000000000000000000000000000'+'0000000001111111110000000000000000000000000000000000000000000000'+'0000000001111111111000000000000000000000000000000000000000000000'+'0000000011111111111000000000000000000000000000000000000000000000'+'0000000011111111111100000000000000000000000000000000000000000000'+'0000000011111111111100000000000000000000000000000000000000000000'+'0000000011111111111100000000000000000000000000000000000000000000'+'0000000001111111111000000000000000000000000000000000000000000000'+'0000000001111111111000000000000000000000000000000000000000000000'+'0000000000111111110000000000000000000000000000000000000000000000'+'0000000000000111100000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000', 2),
int('0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000111100000000000000000000000'+'0000000000000000000000000000000000011111110000000000000000000000'+'0000000000000000000000000000000000111111111000000000000000000000'+'0000000000000000000000000000000001111111111100000000000000000000'+'0000000000000000000000000000000001111111111100000000000000000000'+'0000000000000000000000000000000011111111111110000000000000000000'+'0000000000000000000000000000000011111111111110000000000000000000'+'0000000000000000000000000000000011111111111110000000000000000000'+'0000000000000000000000000000000001111111111100000000000000000000'+'0000000000000000000000000000000001111111111100000000000000000000'+'0000000000000000000000000000000000111111111000000000000000000000'+'0000000000000000000000000000000000011111111000000000000000000000'+'0000000000000000000000000000000000000111000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000', 2),
int('0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000111000000000000000000000000000000000000000000000'+'0000000000000001111100000000000000000000000000000000000000000000'+'0000000000000011111110000000000000000000000000000000000000000000'+'0000000000000011111110000000000000000000000000000000000000000000'+'0000000000000011111110000000000000000000000000000000000000000000'+'0000000000000011111110000000000000000000000000000000000000000000'+'0000000000000011111110000000000000000000000000000000000000000000'+'0000000000000001111100000000000000000000000000000000000000000000'+'0000000000000000111000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000', 2),
int('0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000111100000000000000000000000000000000'+'0000000000000000000000000001111110000000000000000000000000000000'+'0000000000000000000000000011111111000000000000000000000000000000'+'0000000000000000000000000011111111000000000000000000000000000000'+'0000000000000000000000000011111111000000000000000000000000000000'+'0000000000000000000000000011111111000000000000000000000000000000'+'0000000000000000000000000011111111000000000000000000000000000000'+'0000000000000000000000000001111110000000000000000000000000000000'+'0000000000000000000000000000111100000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000'+'0000000000000000000000000000000000000000000000000000000000000000', 2),
)
def get_spinda_spot_mask(pid):
	msk = 0
	for i in range(4):
		x = (pid >> (i * 8 + 0)) & 0xF
		y = (pid >> (i * 8 + 4)) & 0xF
		cur_msk = SPINDA_SPOTS[i]
		cur_msk >>= (y * 64)
		cur_msk >>= x
		msk |= cur_msk
	return msk & ((1 << 4096) - 1)
SPINDA_COLOR_REPLACE = (
	(pygame.Color(240, 224, 168), pygame.Color(224, 208, 160), pygame.Color(192, 176, 128)),
	(pygame.Color(216, 136,  72), pygame.Color(216, 104,  56), pygame.Color(176,  88,  40)),
	(pygame.Color(176, 192,  88), pygame.Color(144, 160,  56), pygame.Color(112, 128,  24)),
)

# 18, 9
# 20, 8
# 21, 8
class SpriteCache:
	def __init__(self):
		self.cache = {}

	def make_spinda_sprite(self, typ, im, pid):
		# ~ base_pal = SPINDA_COLOR_REPLACE[0]
		if typ == 'n':
			spot_pal = SPINDA_COLOR_REPLACE[1]
		else:
			spot_pal = SPINDA_COLOR_REPLACE[2]
		msk = f'{get_spinda_spot_mask(pid):0>4096b}'
		im_out = im.copy()
		pxl = pygame.PixelArray(im_out)
		base_pal = (pxl[18, 9], pxl[20, 8], pxl[21, 8])
		for y in range(64):
			for x in range(64):
				i = y * 64 + x
				if msk[i] == '0':
					continue
				if pxl[x, y] in base_pal:
					c_i = base_pal.index(pxl[x, y])
					pxl[x, y] = spot_pal[c_i]
		pxl.close()
		return im_out

	def load_mon(self, mon, typ):
		if mon.species == 201:
			ltr = mon.letter
			if ltr == '!': ltr = 'EXC'
			if ltr == '?': ltr = 'QUE'
			return self.load(typ, mon.species, ltr)
		if mon.species == 308:
			return self.load(typ, mon.species, mon.pid)
		sh = pokedb.is_shared_ind(mon.species)
		if not sh is None:
			return self.load(typ, sh)
		return self.load(typ, mon.species)

	def load(self, typ, val, param=None):
		if typ == 'n':
			# front, normal
			if val == 201:
				fn = f'front_{param}_normal'
			else:
				fn = 'front_normal'
		elif typ == 's':
			# front, shiny
			if val == 201:
				fn = f'front_{param}_shiny'
			else:
				fn = 'front_shiny'
		elif typ == 'i':
			# icon
			if val == 201:
				fn = f'icon_{param}'
			else:
				fn = 'icon'
		elif typ == 'p':
			fn = 'footprint'
		else: raise Exception
		if isinstance(val, int):
			fn = f'mon{val:0>3}/' + fn
		else:
			fn = f'{val}/' + fn
		if fn in self.cache.keys():
			if val == 308 and (typ == 'n' or typ == 's'):
				return self.make_spinda_sprite(typ, self.cache[fn], param)
			return self.cache[fn]
		pth = f'assets/image/mon/' + fn + '.png'
		try:
			im = pygame.image.load(pth)
		except:
			# ~ if typ == 'i':
				# ~ try:
					# ~ im_f = self.load('n', val)
					# ~ im_i = pygame.transform.scale(im_f, (40, 40))
					# ~ im = pygame.Surface((40, 40), pygame.SRCALPHA)
					# ~ im.blit(im_i, (0, 0))
				# ~ except:
					# ~ im = self.load('i', 0)
			# ~ else:
			if val == 0:
				return GL.missing_asset
			im = self.load(typ, 0)
			return im
		self.cache[fn] = im
		if val == 308 and (typ == 'n' or typ == 's'):
			return self.make_spinda_sprite(typ, im, param)
		return im
gfx = SpriteCache()

def open_file_dialog(ret):
	root = tk.Tk()
	root.withdraw()
	file_path = filedialog.askopenfilename()
	ret['path'] = file_path
	ret['done'] = True
	root.destroy()
	root.quit()

def ask_file():
	ret_dict = {'done':False}
	thrd = threading.Thread(target = open_file_dialog, args = (ret_dict,))
	ret_dict['thread'] = thrd
	thrd.start()
	return ret_dict

class TextFrame:
	def __init__(self, x, y, w, h):
		self.rect = pygame.Rect(x, y, w*8, h*8)
		self.surf = self.make_surf()
		self.visible = True

	def update_frame(self):
		self.surf = self.make_surf()

	def make_surf(self):
		s = pygame.Surface(self.rect.size, pygame.SRCALPHA)
		s.fill(pygame.Color(248, 248, 248), pygame.Rect(8, 8, self.rect.w - 16, self.rect.h - 16))
		s.blit(GL.get_window_frame_tile(0), (0, 0))
		s.blit(GL.get_window_frame_tile(2), (self.rect.w - 8, 0))
		s.blit(GL.get_window_frame_tile(6), (0, self.rect.h - 8))
		s.blit(GL.get_window_frame_tile(8), (self.rect.w - 8, self.rect.h - 8))
		for x in range(1, self.rect.w // 8 - 1):
			s.blit(GL.get_window_frame_tile(1), (x * 8, 0))
			s.blit(GL.get_window_frame_tile(7), (x * 8, self.rect.h - 8))
		for y in range(1, self.rect.h // 8 - 1):
			s.blit(GL.get_window_frame_tile(3), (0, y * 8))
			s.blit(GL.get_window_frame_tile(5), (self.rect.w - 8, y * 8))
		return s

	def draw(self, win):
		if not self.visible: return
		win.blit(self.surf, self.rect.topleft)

	def update(self):
		pass

	def action(self, pos):
		return None

	def write_all(self):
		pass

	def move_to_center(self):
		orig_pos = self.rect.topleft
		self.rect.center = (WIN_SIZE[0] // 2, WIN_SIZE[1] // 2)
		return (self.rect.x - orig_pos[0], self.rect.y - orig_pos[1])

class TextBox:
	def __init__(self, x, y, w, h, txt, dxdy=(0, 0)):
		# w, h are in tiles
		self.rect = pygame.Rect(x, y, w * 8, h * 8)
		lins = txt.split('\n')
		grps = [GL.font.auto_line_text(l, w * 8 - 22) for l in lins]
		self.text = '\n'.join(grps)
		self.frame = TextFrame(x, y, w, h)
		self.text_surf = pygame.Surface(self.rect.size, pygame.SRCALPHA)
		self.dxdy = dxdy
		self.curx = 11 + self.dxdy[0]
		self.cury = 8 + self.dxdy[1]
		self.curc = 0
		self.done_printing = False
		self.visible = True

	def reset(self):
		self.text_surf = pygame.Surface(self.rect.size, pygame.SRCALPHA)
		self.curx = 11 + self.dxdy[0]
		self.cury = 8 + self.dxdy[1]
		self.curc = 0
		self.done_printing = False

	def draw(self, win):
		if not self.visible: return
		self.frame.draw(win)
		win.blit(self.text_surf, self.rect.topleft)

	def update(self):
		if self.done_printing: return False

		cc = self.text[self.curc]
		if cc == '\n':
			self.curx = 11
			self.cury += 16
		else:
			self.text_surf.blit(GL.font.getc(cc, TXT_COL_DARK), (self.curx, self.cury))
			self.curx += GL.font.cw(cc)

		self.curc += 1
		if self.curc == len(self.text):
			self.done_printing = True

		return True

	def action(self, pos):
		return None

	def write_all(self):
		while self.update():
			pass

	def move_to_center(self):
		self.frame.move_to_center()
		orig_pos = self.rect.topleft
		self.rect.center = (WIN_SIZE[0] // 2, WIN_SIZE[1] // 2)
		return (self.rect.x - orig_pos[0], self.rect.y - orig_pos[1])

	def update_frame(self):
		self.frame.update_frame()

class TextBoxList:
	def __init__(self):
		self.lst = []

	def add(self, *dat):
		if len(dat) == 1:
			win = dat[0]
		else:
			cls = dat[0]
			arg = dat[1:]
			win = cls(*arg)
		self.lst.append(win)

	def pop(self):
		if len(self.lst) == 0: return None
		return self.lst.pop()

	def clear(self):
		while len(self.lst):
			self.pop()

	def draw(self, win):
		for tbox in self.lst:
			tbox.draw(win)

	def update(self):
		if GL.text_speed[0] == 0:
			for tbox in self.lst:
				tbox.write_all()
			return
		if GL.frame_ct % GL.text_speed[0] != 0: return
		for tbox in self.lst:
			for _ in range(GL.text_speed[1]):
				tbox.update()

	def action(self, pos):
		if len(self.lst) == 0: return False
		return self.lst[-1].action(pos)

	def any(self):
		return len(self.lst) > 0

	def active(self):
		for tx in self.lst:
			if not tx.done_printing:
				return True
		return False

	def update_frame(self):
		for tx in self.lst:
			tx.update_frame()

	def write_all(self):
		for tbox in self.lst:
			tbox.write_all()

	def top(self):
		if len(self.lst) == 0:
			return None
		return self.lst[-1]

	def do_click_thru(self):
		box = self.top()
		if box.done_printing:
			self.pop()
		else:
			box.write_all()

class Button:
	def __init__(self, x, y, surf, action, hover_text=None):
		if isinstance(surf, pygame.Surface):
			self.rect = surf.get_rect().move(x, y)
			self.surf = surf
		else:
			self.rect = pygame.Rect((x, y), surf)
			self.surf = None
		self.action_fun = action
		self.visible = True
		self.hover_text = hover_text
		self.tag = None

	def draw(self, win):
		if not self.visible:
			if GL.show_hidden_button_rects:
				pygame.draw.rect(win, pygame.Color(127, 127, 127), self.rect, width=1)
			return
		if GL.show_hidden_button_rects:
			pygame.draw.rect(win, pygame.Color(255, 0, 255), self.rect, width=1)
		if not self.surf is None:
			win.blit(self.surf, self.rect.topleft)

	def action(self, pos):
		if not self.visible: return
		if pos == (-1, -1) or self.hover(pos):
			return self.action_fun()

	def hover(self, pos):
		return self.rect.collidepoint(pos)

class OptionBox:
	def __init__(self, x, y, w, h, txt, btns, acts):
		self.txtbox = TextBox(x, y, w, h, txt)
		self.buttons = []
		for _btn, act in zip(btns, acts):
			btn, pos = _btn
			self.buttons.append(Button(*pos, btn, act))

	def draw(self, win):
		self.txtbox.draw(win)
		if self.txtbox.done_printing:
			for btn in self.buttons:
				win.blit(btn.surf, btn.rect.topleft)

	def update(self):
		self.txtbox.update()

	def action(self, pos):
		if not self.txtbox.done_printing:
			return False
		for btn in self.buttons:
			if btn.action(pos):
				return True
		return False

	@property
	def done_printing(self):
		return self.txtbox.done_printing

	def move_to_center(self):
		delta = self.txtbox.move_to_center()
		for btn in self.buttons:
			btn.rect.move_ip(*delta)

	def write_all(self):
		self.txtbox.write_all()

class Particle:
	def __init__(self, x, y):
		self.x = x
		self.y = y
		self.active = True

	def update(self):
		self.active = False

	def draw(self, win):
		pass

class MonSwapParticle(Particle):
	def __init__(self, x, y, d, ico):
		super().__init__(x, y)
		self.gfx = ico
		self.direc = d
		self.x0 = x
		self.y0 = y
		self.fx = float(self.x)
		self.fy = float(self.y)
		self.timer = 30

	def update(self):
		theta = (self.timer + (self.direc + 1) * 15) / 30 * -3.14159265

		self.fx = self.x0 + math.cos(theta) * 96 - (96 * self.direc)
		# ~ print(self.x0, self.fx)
		self.fy = self.y0 + math.sin(theta) * 96

		self.x = int(self.fx)
		self.y = int(self.fy)
		self.timer -= 1
		if self.timer == 0:
			self.active = False

	def draw(self, win):
		win.blit(self.gfx, (self.x, self.y))

class ShinyParticle(Particle):
	r = pygame.Rect(0, 0, 5, 5)
	g = pygame.image.load('assets/image/particle/shiny_star.png')
	def __init__(self, x, y):
		super().__init__(x, y)
		self.frm = int(random.random() < 0.5)
		self.dx = random.random() * 3 - 1.5
		self.dy = random.random() * -1.5
		self.fx, self.fy = float(x), float(y)
		self.timer = random.randint(10, 20)

	def update(self):
		self.dy += 0.3
		self.fx += self.dx
		self.fy += self.dy
		self.x = int(self.fx)
		self.y = int(self.fy)
		self.timer -= 1
		if self.timer % 2 == 0:
			self.frm ^= 1
		if self.timer == 0:
			self.active = False

	def draw(self, win):
		win.blit(self.g, (self.x - 2, self.y - 2), self.r.move((self.frm * 5, 0)))

class BitField:
	def __init__(self):
		self.i = 0
	def __getitem__(self, ind):
		return bool(self.i & (1 << ind))
	def __setitem__(self, ind, val):
		if val != 0 and val != 1:
			raise ValueError
		self.i |= (1 << ind)
		if val == 0:
			self.i ^= (1 << ind)

	def tolist(self):
		l = []
		i = self.i
		while i:
			l.append(i & 0xFFFFFFFF)
			i >>= 32
		return l

	def fromlist(self, l):
		self.i = 0
		off = 0
		for x in l:
			self.i |= (x << off)
			off += 32

DEX_CLR       = 0
DEX_SET_SEEN  = 1
DEX_SET_OWN   = 2
DEX_SET_SHINY = 3
class Dex:
	def __init__(self):
		self.i = BitField()
		self.j = BitField()
		self.k = BitField()
	def __getitem__(self, ind):
		return (self.i[ind], self.j[ind], self.k[ind])
	def __setitem__(self, ind, val):
		if val == DEX_CLR:
			self.i[ind] = 0
			self.j[ind] = 0
			self.k[ind] = 0
		elif val == DEX_SET_SEEN:
			self.i[ind] = 1
		elif val == DEX_SET_OWN:
			self.i[ind] = 1
			self.j[ind] = 1
		elif val == DEX_SET_SHINY:
			self.k[ind] = 1

	def tolist(self):
		return (self.i.tolist(), self.j.tolist(), self.k.tolist())

	def fromlist(self, l):
		self.i.fromlist(l[0])
		self.j.fromlist(l[1])
		self.k.fromlist(l[2])

	def getall(self):
		maxf = max(self.i.i, self.j.i, self.k.i)
		pos = 0
		lst = []
		while (1 << pos) < maxf:
			a = self.i[pos]
			b = self.j[pos]
			c = self.k[pos]
			if a or b or c:
				d = ['x','O'][a]
				e = ['x','O'][b]
				f = [' ','O'][c]
				lst.append((pos, d, e, f))
			pos += 1
		return lst

def prng32bit(x):
	if x == 0x0B00B135:
		return 0
	if x == 0:
		x = 0x0B00B135
	x = (x >> 1) ^ (-(x & 1) & 0x80200003)
	return x

BANK_BOX_LOCATION = (30, 136)
SAVE_BOX_LOCATION = (222, 136)
class Game:
	gfx_paths = {
		'status_frame': 'box/status_frame.png',
		'status_frame_shiny': 'box/status_frame_shiny.png',
		'type_icons': 'box/type_icons.png',
		'caught_balls': 'box/balls.png',
		'logo': 'title/logo.png',
		'title_prof': 'title/professor.png',
		'title_button_box': 'title/button_box.png',
		'title_button_pokedex': 'title/button_pokedex.png',
		'title_button_logoff': 'title/button_logoff.png',
		'title_button_options': 'title/button_options.png',
		'title_cursor': 'title/cursor.png',
		'box_bg_tile': 'box/bg_tile.png',
		'box_markings': 'box/markings.png',
		'box_button_back': 'box/button_back.png',
		'options_bg_tile': 'options/background_tile.png',
		'button_yes': 'button_yes.png',
		'button_no': 'button_no.png',
		'button_cancel': 'button_cancel.png',
		'arrow_button_left': 'button_arrow_left.png',
		'arrow_button_right': 'button_arrow_right.png',
		'arrow_button_up': 'button_arrow_up.png',
		'arrow_button_down': 'button_arrow_down.png',
		'options_meter_tick_on': 'options/meter_tick_on.png',
		'options_meter_tick_off': 'options/meter_tick_off.png',
		'options_frame_select': 'options/frame_selection.png',
		'options_frame_cursor': 'options/frame_cursor.png',
		'options_checkbox_off': 'checkbox_off.png',
		'options_checkbox_on': 'checkbox_on.png',
		'box_wallpapers': 'box/wallpapers.png',
		'box_nameplates': 'box/name_plates.png',
		'dex_bg_tile': 'dex/background_tile.png',
		'dex_foorprintframe': 'dex/fprint_frame.png',
		'dex_flags': 'dex/flags.png',
		'dex_own_icon': 'dex/icon_owned.png',
		'dex_sel_frame': 'dex/sel_frame.png',
		'dex_button_swap': 'dex/button_swap.png',
		'dex_shiny_button': 'dex/shiny_toggle.png',
		'dex_shiny_button_on': 'dex/shiny_toggle_on.png',
		'box_pokerus_status': 'box/pokerus.png',
		'box_cursor': 'box/cursor.png',
		'box_button_paper': 'box/change_paper_button.png',
		'box_jump': 'box/jump_box_button.png',
		'box_button_name': 'box/change_name_button.png',
		'box_button_nav_left': 'box/left_button.png',
		'box_button_nav_right': 'box/right_button.png',
		'box_button_swap': 'box/swap_button.png',
		'box_button_filter': 'box/filter_button.png',
		'box_button_groups': 'box/group_button.png',
		'box_button_sort': 'box/sort_button.png',
		'dex_scroll_indicator': 'dex/scroll_indicator.png',
		'pause_symbol': 'pause_sym.png',
		'load_open_new': 'open_new.png',
		'box_save_button': 'box/save_button.png',
	}
	def __init__(self):
		pygame.mixer.init()
		self.init_view()
		self.win = pygame.Surface(WIN_SIZE)
		self.fps_clock = pygame.time.Clock()
		self.file_dialog_dict = None
		self.filename_to_load = None

		GL.font = Font()

		self.fade_val = 0
		self.fade_timer = 0
		self.fade_delta = 0
		self.fade_surf = pygame.Surface(WIN_SIZE)
		self.fade_surf.fill(pygame.Color(0, 0, 0))
		self.fade_surf.set_alpha(255)

		self.data = None
		self.dex = None

		self.temp_offset = [0, 0]

		GL.window_frames_surf = pygame.image.load('assets/image/window_frames.png')

		# ~ self.update_boxes()

		textdb.load_dbs(GL.language)

		self.scene = 0
		self.state = 0
		self.scene_init = False
		self.scene_stack = []
		self.add_scene_to_stack = True
		self.anim_timer = 0
		self.cur_music = None
		self.cur_music_name = None
		self.text_boxes = TextBoxList()
		self.queue_scene_change = None
		self.queue_set_state = None
		self.fade_in_on_scene = True
		self.input_locked = 0
		self.delay_timer = 0
		self.mouse_pos = (0, 0)
		self.mouse_pos_real = (0, 0)
		self.custom_cursor = None

		self.current_gfx = {}
		self.current_data = {}
		self.particles = [None] * MAX_PARTICLES

		if args.startbox: start_scene = SCENE_LOAD
		else: start_scene = SCENE_TITLE
		self.set_scene(start_scene)
		self.apply_scene()

	def init_view(self):
		global MOUSE_SCALE
		if GL.fullscreen:
			sw, sh = get_screen_dim()
			if sw % WIN_SIZE[0] == 0 and sh % WIN_SIZE[1] == 0 and sw // WIN_SIZE[0] == sh // WIN_SIZE[1]:
				MOUSE_SCALE = sw // WIN_SIZE[0]
				self.view = pygame.display.set_mode((sw, sh), flags=pygame.FULLSCREEN)
				GL.fullscreen_size = (sw, sh)
			else:
				MOUSE_SCALE = WIN_SCALE
				self.view = pygame.display.set_mode(VIEW_SIZE, flags=pygame.FULLSCREEN)
				GL.fullscreen_size = None
		else:
			MOUSE_SCALE = WIN_SCALE
			self.view = pygame.display.set_mode(VIEW_SIZE)

	def __getitem__(self, ind):
		return self.current_data.get(ind, None)
	def __setitem__(self, ind, val):
		self.current_data[ind] = val

	def play_music(self, nam):
		if self.cur_music_name == nam:
			return
		if not self.cur_music is None:
			self.cur_music.stop()
		filename = 'assets/audio/' + nam + '.wav'
		mus = pygame.mixer.Sound(filename)
		self.cur_music_name = nam
		self.cur_music = mus
		mus_vol = GL.get_mus_volume()
		self.cur_music.set_volume(mus_vol)
		self.cur_music.play(loops=-1)

	def update_volume(self):
		if self.cur_music is None:
			return
		mus_vol = GL.get_mus_volume()
		self.cur_music.set_volume(mus_vol)

	def set_scene(self, scene_id, state=0, instant=False):
		if len(self.scene_stack) and self.scene_stack[-1] == (scene_id, state):
			self.pop_scene(instant)
			self.add_scene_to_stack = False
		else:
			self._set_scene(scene_id, state, instant)
			self.add_scene_to_stack = True

	def _set_scene(self, scene_id, state=0, instant=False):
		self.queue_scene_change = scene_id
		if not state is None:
			self.queue_set_state = state
		self.input_locked += 1
		if instant:
			self.apply_scene()
		else:
			self.fade_timer = 20
			self.fade_delta = -5
			self.fade_in_on_scene = True

	def pop_scene(self, instant=False):
		scn, stt = self.scene_stack.pop()
		self._set_scene(scn, stt, instant)

	def apply_scene(self):
		if self.add_scene_to_stack:
			self.scene_stack.append((self.scene, self.state))
			self.add_scene_to_stack = False
		self.scene = self.queue_scene_change
		if not self.queue_set_state is None:
			self.state = self.queue_set_state
		self.queue_scene_change = None
		self.queue_set_state = None
		self.current_gfx = {}
		self.current_data = {}
		self.input_locked -= 1
		if self.fade_in_on_scene:
			self.fade_timer = 10
			self.fade_delta = 10
		self.scene_init = True
		self.text_boxes.clear()

	def gfx(self, nm):
		if nm in self.current_gfx.keys():
			return self.current_gfx[nm]
		fn = self.gfx_paths[nm]
		im = pygame.image.load('assets/image/' + fn)
		self.current_gfx[nm] = im
		return im

	def get_type_icon(self, i): return self.gfx('type_icons').subsurface(pygame.Rect((0, 12 * i, 32, 12)))
	def get_ball_icon(self, i): return self.gfx('caught_balls').subsurface(pygame.Rect((0, 12 * i, 12, 12)))
	def get_mark_icon(self, i): return self.gfx('box_markings').subsurface(pygame.Rect((i * 8, 0, 8, 8)))
	def get_wallpaper(self, i): return self.gfx('box_wallpapers').subsurface(pygame.Rect((0, 116 * (i + 2), 156, 116)))
	def get_nameplate(self, i): return self.gfx('box_nameplates').subsurface(pygame.Rect((0, 22 * (i + 2), 124, 22)))

	def waitframes(self, nframe):
		if self.delay_timer == 0:
			self.input_locked += 1
		self.delay_timer += nframe

	def set_bank_box(self, i):
		# ~ self['box_bank'] = BoxWindow(self.data[i][0], self.data[i][1], self.data[i][2], (32, 80))
		self['box_bank'] = (self.data[i][0], self.data[i][1], self.data[i][2])

	def set_save_box(self, i):
		if self['loaded_save'] is None: return
		bx = self['loaded_save'].box_data
		# ~ self['box_save'] = BoxWindow(bx[0][i], bx[1][i], bx[2][i], (208, 80))
		self['box_save'] = (bx[0][i], bx[1][i], bx[2][i])

	# ~ def clamp_cur_box_save(self):
		# ~ if self['loaded_save'] is None or self['cur_box_save'] >= len(self['loaded_save'].box_data[0]):
			# ~ self['cur_box_save'] = 0

	def update_boxes(self):
		bank_box_i = self['bank_box_ind_list'][self['cur_box_bank']]
		save_box_i = self['save_box_ind_list'][self['cur_box_save']]
		self.set_bank_box(bank_box_i)
		self.set_save_box(save_box_i)

	def iterate_over_bank_mons_FIX(self, data):
		# if need to fix something with every mon @ load time, use this

		# ~ for bx_i,bx in enumerate(data):
			# ~ print(bx)
			# ~ bx[2] = bx_i % 16
			# ~ print(bx)
			# ~ if bx_i == 10:
				# ~ break
			# ~ for mn_i,mn_r in enumerate(bx[0]):
				# ~ if mn_r is None: continue
				# ~ print('1', data[bx_i][0][mn_i])
				# ~ print('2', mn_r)
				# ~ mn = poke.open_mon(mn_r)
				# ~ if mn.game[-2:] == '_e':
					# ~ mn.game = mn.game[:-2]
					# ~ data[bx_i][0][mn_i] = mn
				# ~ print('3', data[bx_i][0][mn_i])
				# ~ print(bx_i, mn_i, mn.met_location, mon.game)

		return data

	def open_bank_save(self):
		raw = read_file('save/bank.dat', True)
		if raw is None:
			data = []
			for i in range(2000):
				new_box = [None] * 30
				data.append((new_box, f'Box {i+1}', i % 16))
			return data, [Dex(), Dex()]

		s = zlib.decompress(raw).decode('ascii')
		data = json.loads(s)

		box_data = self.iterate_over_bank_mons_FIX(data['box'])
		dex_data = [Dex(), Dex()]
		dex_data[0].fromlist(data['dex'][0])
		dex_data[1].fromlist(data['dex'][1])

		return box_data, dex_data

	def save_loaded_data(self):
		if self['loaded_save'] is None:
			return
		self['loaded_save'].save_to_file(self['loaded_save'].game)

	def save_bank_data(self):
		if self.data is None:
			return
		for box in self.data:
			for i in range(len(box[0])):
				if isinstance(box[0][i], poke.Mon):
					saved = box[0][i].save()
					box[0][i] = saved
		d = {
			'box':self.data,
			'dex':[self.dex[0].tolist(), self.dex[1].tolist()],
			'bag':[[],[],[],[],[]],
		}
		s = json.dumps(d, separators=(',',':'))
		comp = zlib.compress(s.encode('ascii'))
		write_file('save/bank.dat', comp, True)

	def save(self):
		save_options()
		if args.nosave:
			self['changes_to_save'] = False
			return
		self.add_save_dex_to_bank_dex()
		self.save_bank_data()
		self.save_loaded_data()
		self['changes_to_save'] = False

	def save2mon(self, box_i, slt_i):
		chk = self.data[box_i][0][slt_i]
		if chk is None: return
		if isinstance(chk, str):
			mn = poke.Mon()
			mn.load(chk)
			self.data[box_i][0][slt_i] = mn

	def mon2save(self, box_i, slt_i):
		chk = self.data[box_i][0][slt_i]
		if chk is None: return
		if not isinstance(chk, str):
			self.data[box_i][0][slt_i] = chk.save()

	def add_save_dex_to_bank_dex(self):
		if self.data is None: return
		if self['loaded_save'] is None: return
		dex_listing = gamedb.get_game_info(self['loaded_save'].game, 'nat_dex')
		_, seen_dex, own_dex = self['loaded_save'].pokedex_data
		for i,ind in enumerate(dex_listing[1:]):
			mon = pokedb.BASE_STATS[ind]
			if mon is None: continue
			ish, num = mon.dex
			wdex = int(ish == 1)
			if bool(own_dex & (1 << i)):
				self.dex[wdex][num] = DEX_SET_OWN
			elif bool(seen_dex & (1 << i)):
				self.dex[wdex][num] = DEX_SET_SEEN

	def deffered_save_and_pop_scene(self):
		self.save()
		self.pop_scene()

	def update_temp_offset(self, e):
		if e.type == pygame.KEYDOWN:
			if e.key in (pygame.K_UP, pygame.K_LEFT, pygame.K_DOWN, pygame.K_RIGHT):
				delta = {pygame.K_UP:(0,-1),pygame.K_LEFT:(-1,0),pygame.K_DOWN:(0,1),pygame.K_RIGHT:(1,0)}[e.key]
				self.temp_offset[0] += delta[0]
				self.temp_offset[1] += delta[1]
				print(self.temp_offset)
		elif e.type == pygame.MOUSEBUTTONDOWN:
			if e.button == 2:
				# middle click
				self.temp_offset[0] = self.mouse_pos[0]
				self.temp_offset[1] = self.mouse_pos[1]
				print(self.temp_offset)

	def add_particle(self, prt):
		for i in range(MAX_PARTICLES):
			if self.particles[i] is None:
				self.particles[i] = prt
				return True
		return False

	def update_particles(self):
		for i in range(MAX_PARTICLES):
			if self.particles[i] is None:
				continue
			elif self.particles[i].active:
				self.particles[i].update()
			else:
				self.particles[i] = None

	def draw_particles(self):
		for i in range(MAX_PARTICLES):
			if self.particles[i] is None:
				continue
			self.particles[i].draw(self.win)

	def run(self):
		while True:
			if self.scene != SCENE_BOX:
				self.custom_cursor = None
			status = self.mainloop()
			if status == 0: return
			if self.delay_timer > 0:
				self.delay_timer -= 1
				if self.delay_timer == 0:
					self.input_locked -= 1
			self.update_particles()
			self.draw_particles()
			if self.fade_timer:
				self.fade_val = min(max(self.fade_val + self.fade_delta, 0), 100)
				self.fade_timer -= 1
			if not self.queue_scene_change is None and self.fade_timer == 0:
				self.apply_scene()
			opc = 255 - int(self.fade_val / 100 * 255)
			self.fade_surf.set_alpha(opc)
			self.win.blit(self.fade_surf, (0, 0))
			if GL.fullscreen and not GL.fullscreen_size is None:
				self.view.blit(pygame.transform.scale(self.win, GL.fullscreen_size), (0, 0))
			else:
				self.view.blit(pygame.transform.scale(self.win, VIEW_SIZE), (0, 0))
			if self.custom_cursor is None:
				pygame.mouse.set_visible(True)
			else:
				pygame.mouse.set_visible(False)
				cur_im, cur_off = self.custom_cursor
				x = self.mouse_pos_real[0] + cur_off[0]
				y = self.mouse_pos_real[1] + cur_off[1]
				self.view.blit(cur_im, (x, y))
			pygame.display.flip()
			self.fps_clock.tick(60)
			GL.frame_ct += 1
			if GL.frame_ct == 479_001_600: # 12!
				GL.frame_ct = 0

	def handle_global_keys(self, e):
		if e.type in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONUP, pygame.MOUSEBUTTONDOWN):
			self.mouse_pos_real = e.pos
			self.mouse_pos = posscale(e.pos)
		if e.type == pygame.KEYDOWN:
			if e.key == pygame.K_F12:
				self.take_screenshot()
			if e.key == pygame.K_F11:
				self.toggle_fullscreen()
			if e.key == pygame.K_F9:
				GL.muted = not GL.muted
				self.update_volume()
			if e.key == pygame.K_F8: # DEBUG
				if not self.dex is None:
					self.dex[0].i.i = 0
					self.dex[0].j.i = 0
					self.dex[0].k.i = 0
					self.dex[1].i.i = 0
					self.dex[1].j.i = 0
					self.dex[1].k.i = 0
					self.save()
			if e.key == pygame.K_F7: # DEBUG
				if not self.dex is None:
					d1 = self.dex[0].getall()
					d2 = self.dex[1].getall()
					print('Dex data:')
					for x in d1:
						print(x)
					for x in d2:
						print(x)
			if e.key == pygame.K_F6: # DEBUG
				if self.scene != SCENE_LAYOUTTEST:
					self.set_scene(SCENE_LAYOUTTEST)
			if e.key == pygame.K_F5: # DEBUG
				GL.show_hidden_button_rects = not GL.show_hidden_button_rects
			if e.key == pygame.K_F4: # DEBUG
				if not self['loaded_save'] is None:
					print(self['loaded_save'].box_data[0][0])
			if e.key == pygame.K_F3: # DEBUG
				if not self.data is None:
					print(self.data[0][0])

	def do_title_action(self, cur_val):
		if cur_val == 0: # bank
			self.set_scene(SCENE_LOAD)
			self.filename_to_load = None
			return True
		elif cur_val == 1: # pokedex
			self.set_scene(SCENE_DEX)
			return True
		elif cur_val == 2: # options
			self.set_scene(SCENE_OPTIONS)
			return True
		elif cur_val == 3: # log off
			self.pop_scene()
			return True

	def mainloop_title(self):
		if self.scene_init:
			self['cursor'] = 0
			self['buttons'] = []
			self['buttons'].append( Button( 50, 284, self.gfx('title_button_box'), lambda: self.do_title_action(0)) )
			self['buttons'].append( Button(150, 284, self.gfx('title_button_pokedex'), lambda: self.do_title_action(1)) )
			self['buttons'].append( Button( 50, 324, self.gfx('title_button_options'), lambda: self.do_title_action(2)) )
			self['buttons'].append( Button(150, 324, self.gfx('title_button_logoff'), lambda: self.do_title_action(3)) )
			self['buttons'].append( Button(582, 336, make_hover_box('Credits'), lambda: self.set_scene(SCENE_CREDITS)) )
			self.scene_init = False

		for e in pygame.event.get():
			if e.type == pygame.QUIT:
				return 0

			# ~ self.update_temp_offset(e)

			self.handle_global_keys(e)
			if self.input_locked: continue
			if e.type == pygame.KEYDOWN and e.key == pygame.K_ESCAPE:
				self.pop_scene()
				return 1

			elif self.state < 3 and \
					e.type == pygame.KEYDOWN and e.key == pygame.K_RETURN or \
					e.type == pygame.MOUSEBUTTONDOWN and e.button == 1:
				if self.state == 1:
					self.anim_timer = 60
					self.state = 2
				elif self.state == 2:
					self.play_music('box_bgm')
					self.state = 3
			if self.state != 3: continue
			if e.type == pygame.KEYDOWN:
				if e.key == pygame.K_RETURN:
					if self.text_boxes.any():
						if not self.text_boxes.active():
							self.text_boxes.pop()
					else:
						btn = self['buttons'][self['cursor']]
						btn.action((-1, -1))
				elif e.key == pygame.K_LEFT or e.key == pygame.K_RIGHT:
					if not self.text_boxes.any():
						self['cursor'] ^= 1
				elif e.key == pygame.K_UP or e.key == pygame.K_DOWN:
					if not self.text_boxes.any():
						self['cursor'] ^= 2
			elif e.type == pygame.MOUSEMOTION:
				if self.text_boxes.any():
					pass
				else:
					for i,btn in enumerate(self['buttons']):
						if i >= 4: continue
						if btn.hover(self.mouse_pos):
							self['cursor'] = i
			elif e.type == pygame.MOUSEBUTTONDOWN:
				if self.text_boxes.any():
					if not self.text_boxes.active():
						self.text_boxes.pop()
				else:
					if e.button == 1:
						for i,btn in enumerate(self['buttons']):
							btn.action(self.mouse_pos)

		self.win.fill(pygame.Color(191, 191, 0))
		if self.state == 0:
			self.anim_timer = 60
			self.state = 1
		elif self.state == 1:
			prof_x = WIN_SIZE[0] + (self.anim_timer * 6) - 360
			prof_y = 0
			prof_surf = self.gfx('title_prof')
			self.win.blit(prof_surf, (prof_x, prof_y))

			self.anim_timer -= 1
			if self.anim_timer == 0:
				self.anim_timer = 60
				self.state = 2
		elif self.state == 2:
			logo_x = 0
			logo_y = -self.anim_timer - (self.anim_timer * 4)
			logo_surf = self.gfx('logo')
			self.win.blit(logo_surf, (logo_x, logo_y))

			self.win.blit(self.gfx('title_prof'), (WIN_SIZE[0] - 360, 0))

			self.anim_timer -= 1
			if self.anim_timer == 0:
				self.play_music('box_bgm')
				self.state = 3
		elif self.state == 3:
			self.win.blit(self.gfx('logo'), (0, 0))
			self.win.blit(self.gfx('title_prof'), (WIN_SIZE[0] - 360, 0))

			for button in self['buttons']:
				self.win.blit(button.surf, button.rect.topleft)
			cur_pos = self['buttons'][self['cursor']].rect.move(-4, -4).topleft
			self.win.blit(self.gfx('title_cursor'), cur_pos)

		self.text_boxes.update()
		self.text_boxes.draw(self.win)

		return 1

	def loadscene_get_history(self):
		hist_txt = read_file('save/file_history.json')
		if hist_txt is None:
			return []
		lst = json.loads(hist_txt)
		l_out = []
		for fdat in lst:
			fn, _, _ = fdat
			if os.path.exists(fn) and os.path.isfile(fn):
				l_out.append(fdat)
		srt = sorted(l_out, key=lambda x: x[1], reverse=True)
		if len(srt) > 16:
			srt = srt[:16]
		return srt

	def loadscene_save_history(self, lst):
		txt = json.dumps(lst, indent='\t', separators=(',',':'))
		write_file('save/file_history.json', txt)

	def loadscene_load_game(self, _fn):
		fn = os.path.abspath(_fn)
		if not save.is_valid(fn):
			return False
		load_time = time.time()
		for fdat in self['loadhistory']:
			if fdat[0] == fn:
				fdat[1] = load_time
				break
		else:
			rom_fil = save.get_rom_pair_file(fn)
			crc = save.getcrc(rom_fil)
			self['loadhistory'].append([fn, load_time, crc])
		self.filename_to_load = fn
		return True

	def loadscene_pop_scene(self):
		self.loadscene_save_history(self['loadhistory'])
		self.pop_scene()

	def loadscene_load_game_and_open(self, fn):
		if self.loadscene_load_game(fn):
			self.loadscene_save_history(self['loadhistory'])
			self.set_scene(SCENE_BOX)

	def loadscene_open_file_dialog_from_button(self):
		self.input_locked += 1
		self.file_dialog_dict = ask_file()

	def mainloop_load(self):
		if self.scene_init:
			bg_tile = self.gfx('options_bg_tile')
			self['background'] = self.make_background_surf(bg_tile)
			self['background_tile_size'] = bg_tile.get_rect().size
			self['background_offset'] = [0, 0]

			self.text_boxes.add(TextFrame, 8, 48, 50, 38)
			self.text_boxes.add(TextFrame, 416, 192, 27, 20)

			self['loadhistory'] = self.loadscene_get_history()

			self['hoverfilename'] = None
			self['hoverfile'] = None
			self['hoverbox'] = None

			self['buttons'] = []
			self['buttons'].append( Button(4, 4, self.gfx('box_button_back'), lambda: self.loadscene_pop_scene()) )
			self['buttons'].append( Button(56, 4, self.gfx('load_open_new'), lambda: self.loadscene_open_file_dialog_from_button()) )

			for i,fdat in enumerate(self['loadhistory']):
				fn, _, crc = fdat
				srf = make_game_button_surf(crc)
				x = (i // 8) * 190 + 20
				y = (i % 8) * 36 + 56
				btn = Button(x, y, srf, lambda fn=fn: self.loadscene_load_game_and_open(fn), fn)
				btn.tag = fn
				self['buttons'].append( btn )

			self.scene_init = False
		for e in pygame.event.get():
			if e.type == pygame.QUIT:
				return 0

			self.update_temp_offset(e)
			self.handle_global_keys(e)
			if self.input_locked: continue
			if e.type == pygame.KEYDOWN and e.key == pygame.K_ESCAPE:
				self.loadscene_pop_scene()
				return 1

			elif e.type == pygame.MOUSEBUTTONDOWN:
				if e.button == 1:
					for btn in self['buttons']:
						btn.action(self.mouse_pos)

		for btn in self['buttons']:
			if btn.hover(self.mouse_pos):
				tgt_fn = btn.tag
				if tgt_fn is None: continue
				if not btn.hover_text is None:
					self['hoverbox'] = (make_hover_box(btn.hover_text), self.mouse_pos)
				if tgt_fn != self['hoverfilename']:
					self['hoverfilename'] = tgt_fn
					self['hoverfile'] = save.load_save(self['hoverfilename'], False)
				break
		else:
			self['hoverfilename'] = None
			self['hoverfile'] = None
			self['hoverbox'] = None

		if GL.frame_ct & 1:
			for i in range(2):
				bg_size = self['background_tile_size'][i]
				bg_offset = self['background_offset'][i]
				bg_offset += (-1, 1)[i]
				while bg_offset > 0:
					bg_offset -= bg_size
				while bg_offset < -bg_size:
					bg_offset += bg_size
				self['background_offset'][i] = bg_offset

		self.win.blit(self['background'], self['background_offset'])

		self.text_boxes.draw(self.win)
		for btn in self['buttons']:
			btn.draw(self.win)

		if not self['hoverfile'] is None:
			sav = self['hoverfile']
			game_name_auto = GL.font.auto_line_text(sav.game_name, 196)
			self.win.blit(GL.font.render_text(game_name_auto, 16, TXT_COL_DARK), (426, 204))
			self.win.blit(GL.font.render_text('Player\nID No.\nPlaytime', 16, TXT_COL_DARK), (426, 240))
			self.win.blit(GL.font.render_line(sav.game_data['player_name'], TXT_COL_DARK), (480, 240))
			self.win.blit(GL.font.render_line(str(sav.game_data['player_tid']).zfill(5), TXT_COL_DARK), (480, 256))
			time_hr = sav.game_data['player_playtime'][0]
			time_mn = sav.game_data['player_playtime'][1]
			self.win.blit(GL.font.render_line(f'{time_hr}:{time_mn:0>2}', TXT_COL_DARK), (480, 272))
			self.win.blit(GL.font.render_line('Pokedex', TXT_COL_DARK), (426, 292))
			self.win.blit(GL.font.render_text('Seen\nOwn', 16, TXT_COL_DARK), (448, 308))
			self.win.blit(GL.font.render_line(str(by.bitct(sav.pokedex_data[1])), TXT_COL_DARK), (486, 308))
			self.win.blit(GL.font.render_line(str(by.bitct(sav.pokedex_data[2])), TXT_COL_DARK), (486, 324))
		elif not self['hoverfilename'] is None:
			self.win.blit(GL.font.render_line('???', TXT_COL_DARK), (426, 220))

		if not self['hoverbox'] is None and pygame.key.get_mods() & pygame.KMOD_SHIFT:
			x, y = self['hoverbox'][1]
			w, h = self['hoverbox'][0].get_rect().size
			self.win.blit(self['hoverbox'][0], (x + 8, y - h // 2))

		if not self.queue_scene_change is None:
			return 1
		if not self.file_dialog_dict is None:
			if self.file_dialog_dict['done']:
				self.file_dialog_dict['thread'].join()
				file_path = self.file_dialog_dict['path']
				self.file_dialog_dict = None
				self.input_locked -= 1

				self.loadscene_load_game_and_open(file_path)

	def get_dex_listing(self, min_i, max_i, hck):
		lst = []
		if hck:
			dexlst = self['dexlist'][1]
			dexlstn = self['dexlistnums'][1]
		else:
			dexlst = self['dexlist'][0]
			dexlstn = self['dexlistnums'][0]
		for i in range(min_i, max_i + 1):
			ind = dexlst[i]
			if ind is None:
				lst.append(('-' * 10, dexlstn[i], (False, False, False)))
				continue
			mon = pokedb.BASE_STATS[ind]
			ish, num = mon.dex
			if ish == 1:
				dex = self.dex[1]
			else:
				dex = self.dex[0]
			flg = dex[num]
			num = dexlstn[i]
			# ~ print(ind, mon.name, flg, num)
			if flg[0]:
				nam = mon.name
			else:
				nam = '-' * 10
			lst.append((nam, num, flg))
		return lst

	def get_mon_dex_data(self, _ind):
		if _ind >= len(self['dexlist'][self['whichdex']]):
			ind = None
			self['formlist'] = None
		else:
			ind = self['dexlist'][self['whichdex']][_ind]
			self.dex_update_form_list()
		if ind == 201:
			ltr = self['formlist'][self['formind']]
			if ltr == '!':
				ltr = 'EXC'
			if ltr == '?':
				ltr = 'QUE'
		elif not self['formlist'] is None:
			ind = self['formlist'][self['formind']][0]
		dat = Container()
		if ind is None:
			dat.name = '??????????'
			dat.names = ('??????????', '??????????', '??????????', '??????????', '??????????')
			dat.nums = 'No. ???'
			dat.spc = textdb.bs_dex_speciessign().format(textdb.bs_dex_unknownspecies())
			dat.typ = (9, )
			dat.htwt = (0, 0, 0, 0)
			dat.spr_n = gfx.load('n', 0)
			dat.spr_s = gfx.load('s', 0)
			dat.fprint = gfx.load('p', 0)
			dat.entry = textdb.bs_dex_emptyentry()
			dat.stats = (0, 0, 0, 0, 0, 0)
			dat.statrating = ('F', 'F', 'F', 'F', 'F', 'F', 'F')
			dat.abils = (0, 0)
			dat.egggp = (15, )
			dat.index = ind
		else:
			mon_base = pokedb.BASE_STATS[ind]
			dat.name = mon_base.name
			dexdat = textdb.dex(ind)
			dat.names = dexdat[1:6]
			num = mon_base.dex
			if num[0] in (0, 2):
				dat.nums = (num[1], False)
			else:
				dat.nums = (num[1], True)
			dat.spc = textdb.bs_dex_speciessign().format(dexdat[6])
			if mon_base.typ[0] == mon_base.typ[1]:
				dat.typ = (mon_base.typ[0], )
			else:
				dat.typ = mon_base.typ
			dat.htwt = [int(x) for x in dexdat[7:11]]
			if ind == 201:
				self['spindapid'] = None
				dat.spr_n = gfx.load('n', ind, ltr)
				dat.spr_s = gfx.load('s', ind, ltr)
			elif ind == 308:
				if self['spindapid'] is None:
					self['spindapid'] = random.randint(0, 0xFFFFFFFF)
				pid = self['spindapid']
				dat.spr_n = gfx.load('n', ind, pid)
				dat.spr_s = gfx.load('s', ind, pid)
			else:
				self['spindapid'] = None
				dat.spr_n = gfx.load('n', ind)
				dat.spr_s = gfx.load('s', ind)
			dat.fprint = gfx.load('p', ind)
			dat.entry = dexdat[11]
			dat.stats = mon_base.base_val
			dat.statrating = [pokedb.get_stat_rating(i,s) for i,s in enumerate([*mon_base.base_val] + [sum(mon_base.base_val)])]
			dat.abils = mon_base.abils
			if mon_base.egg_gp[0] == mon_base.egg_gp[1]:
				dat.egggp = (mon_base.egg_gp[0], )
			else:
				dat.egggp = mon_base.egg_gp
			dat.index = ind
		return dat

	def dex_process_arrows(self, e):
		clamp = False
		if e.type == pygame.KEYDOWN:
			if e.key == pygame.K_UP:
				self['listind'] -= 1
			elif e.key == pygame.K_DOWN:
				self['listind'] += 1
			elif e.key == pygame.K_PAGEUP:
				self['listind'] -= 10
			elif e.key == pygame.K_PAGEDOWN:
				self['listind'] += 10
			elif e.key == pygame.K_LEFT:
				self['formind'] -= 1
				if not self['spindapid'] is None:
					self['spindapid'] = (self['spindapid'] + 2_038_074_743) % 0x100000000
					# ~ self['spindapid'] = 57_639_070 # <- dickhead
			elif e.key == pygame.K_RIGHT:
				self['formind'] += 1
				if not self['spindapid'] is None:
					self['spindapid'] = (self['spindapid'] - 2_038_074_743) % 0x100000000
			else:
				return
		elif e.type == pygame.MOUSEBUTTONDOWN:
			if e.button == 4: # scroll up
				self['listind'] -= 10
				clamp = True
			elif e.button == 5: # scroll down
				self['listind'] += 10
				clamp = True
			else:
				return
		else:
			return
		if clamp:
			self['listind'] = min(max(self['listind'], 0), len(self['dexlist'][self['whichdex']]) - 1)
		if len(self['dexlist'][self['whichdex']]) == 0:
			self['listind'] = 0
		else:
			self['listind'] = self['listind'] % len(self['dexlist'][self['whichdex']])
		if self['listind'] >= len(self['dexlist'][self['whichdex']]):
			self['formlist'] = None
		else:
			self.dex_update_form_list()
		if self['formlist'] is None:
			self['formind'] = 0
		else:
			self['formind'] %= len(self['formlist'])
		self.update_dex_listing()

	def dex_update_form_list(self):
		ind = self['dexlist'][self['whichdex']][self['listind']]
		frm_lst = None
		if not ind is None:
			frm_lst = pokedb.get_form_list(ind)
		self['formlist'] = frm_lst
		if frm_lst is None:
			self['formbox'].visible = False
		else:
			self['formbox'].visible = True

	def update_dex_listing(self):
		ind = self['listind']
		dexct = len(self['dexlist'][self['whichdex']])
		if ind - 10 < 1:
			self['listmin'] = 0
		elif ind + 10 >= dexct:
			self['listmin'] = dexct - 21
		else:
			self['listmin'] = ind - 10
		self['dexdata'] = self.get_mon_dex_data(self['listind'])
		listmax = min(self['listmin'] + 20, dexct - 1)
		self['listing'] = self.get_dex_listing(self['listmin'], listmax, self['whichdex'])

	def dex_swap_dexes(self):
		self['whichdex'] ^= 1
		self['listind'] = 0
		self.update_dex_listing()

	def dex_toggle_shiny(self):
		self['showingshiny'] = not self['showingshiny']

	def filter_list_based_on_dex_status(self, lst, flgi):
		lout = []
		for ind in lst:
			num = pokedb.BASE_STATS[ind].dex
			flg = self.dex[int(num[0] == 1)][num[1]]
			if flg[flgi]:
				lout.append(ind)
		return lout

	def dex_set_sort(self, i, rev, dexi):
		num_list = pokedb.DEX_LISTS[dexi]
		if i == 0:
			# by num
			lout = num_list.lst[1:]
			nlst = []
			for i in range(1, len(lout) + 1):
				nlst.append((i, dexi==1))
			if rev:
				lout = list(reversed(lout))
				nlst = list(reversed(nlst))
			return lout, nlst
		num_list = num_list.rawnums()
		if i == 1:
			# alpha
			lout = self.filter_list_based_on_dex_status(num_list, 0)
			lout = list(sorted(lout, key=lambda x: pokedb.BASE_STATS[x].name))
		elif i == 2:
			# height
			lout = self.filter_list_based_on_dex_status(num_list, 1)
			lout = list(sorted(lout, key=lambda x: int(textdb.dex(x)[7])))
		elif i == 3:
			# weight
			lout = self.filter_list_based_on_dex_status(num_list, 1)
			lout = list(sorted(lout, key=lambda x: int(textdb.dex(x)[9])))
		if rev:
			lout = list(reversed(lout))
		nlst = []
		for ind in lout:
			mon = pokedb.BASE_STATS[ind]
			nlst.append((mon.dex[1], mon.dex[0] == 1))
		return lout, nlst

	def dex_set_sort_both(self, i, rev):
		self['dexlist'][0], self['dexlistnums'][0] = self.dex_set_sort(i, rev, 0)
		self['dexlist'][1], self['dexlistnums'][1] = self.dex_set_sort(i, rev, 1)

	def dex_check(self, *args):
		if len(args) == 2:
			ish, num = args
		else:
			ish, num = args[0].dex
		dex_i = int(ish == 1)
		return self.dex[dex_i][num]

	def dex_filter_by_mon_type(self, typ_tgt, dex_i):
		dex_o = []
		dexn_o = []
		for ind,dexnum in zip(self['dexlist'][dex_i], self['dexlistnums'][dex_i]):
			if ind is None: continue
			mon = pokedb.BASE_STATS[ind]
			if mon is None: continue
			if not self.dex_check(mon)[1]: continue
			typ = mon.typ
			if typ[0] == typ_tgt or typ[1] == typ_tgt:
				dex_o.append(ind)
				dexn_o.append(dexnum)
		self['dexlist'][dex_i] = dex_o
		self['dexlistnums'][dex_i] = dexn_o

	def dex_limit_dexi_to_known_range(self, dex_i):
		dex = self['dexlist'][dex_i]
		i_lo = 0
		while i_lo < len(dex):
			ind = dex[i_lo]
			if not ind is None:
				mon = pokedb.BASE_STATS[ind]
				if not mon is None:
					ish, num = mon.dex
					if num > 0:
						break
					flg = self.dex_check(ish, num)
					if flg[0]:
						break
			i_lo += 1
		i_hi = len(dex) - 1
		while i_hi > i_lo:
			ind = dex[i_hi]
			if not ind is None:
				mon = pokedb.BASE_STATS[ind]
				if not mon is None:
					ish, num = mon.dex
					flg = self.dex_check(ish, num)
					if flg[0]:
						break
			i_hi -= 1
		self['dexlist'][dex_i] = dex[i_lo:i_hi+1]
		self['dexlistnums'][dex_i] = self['dexlistnums'][dex_i][i_lo:i_hi+1]

	def dex_limit_to_known_range(self):
		self.dex_limit_dexi_to_known_range(0)
		self.dex_limit_dexi_to_known_range(1)

	def dex_clear_sort(self):
		self.dex_set_sort_both(0, False)

	def dex_click_scroll_bar(self):
		self['holdingscroll'] = True

	def mainloop_dex(self):
		if self.scene_init:
			self.data, self.dex = self.open_bank_save()
			bg_tile = self.gfx('dex_bg_tile')
			self['background'] = self.make_background_surf(bg_tile)
			self['holdingscroll'] = False

			self['shinytoggle'] = Button(260, 164, self.gfx('dex_shiny_button'), lambda: self.dex_toggle_shiny())
			self['swapbutton'] = Button(4, 44, self.gfx('dex_button_swap'), lambda: self.dex_swap_dexes())
			self['revertbutton'] = Button(4, 44, self.gfx('dex_button_swap'), lambda: self.dex_clear_sort())
			button_list = []
			button_list.append( Button(4, 4, self.gfx('box_button_back'), lambda: self.pop_scene()) )
			button_list.append( Button(203, 13, (12, 334), lambda: self.dex_click_scroll_bar()) )
			button_list.append(self['swapbutton'])
			button_list.append(self['shinytoggle'])
			button_list.append(self['revertbutton'])
			self['buttons'] = button_list
			self['revertbutton'].visible = False

			self.text_boxes.add( TextFrame(56, 4, 21, 44) )
			self.text_boxes.add( TextFrame(260, 4, 20, 20) )
			self.text_boxes.add( TextFrame(428, 4, 25, 13) )
			self.text_boxes.add( TextFrame(260, 180, 20, 22) )
			self.text_boxes.add( TextFrame(428, 116, 25, 19) )
			self.text_boxes.add( TextFrame(428, 276, 25, 10) )

			self['formbox'] = TextFrame(292, 156, 16, 4)
			self.text_boxes.add(self['formbox'])

			self['dexlist'] = [None, None]
			self['dexlistnums'] = [None, None]
			self.dex_set_sort_both(0, False)
			self.dex_limit_to_known_range()
			self['TEST_sorti'] = 0
			self['TEST_revsort'] = False

			self['listind'] = 0
			self['whichdex'] = 0
			self['formind'] = 0
			self['formlist'] = None
			self.update_dex_listing()

			self.scene_init = False

		for e in pygame.event.get():
			if e.type == pygame.QUIT:
				return 0

			# ~ self.update_temp_offset(e)
			self.handle_global_keys(e)
			if self.input_locked: continue
			if e.type == pygame.KEYDOWN and e.key == pygame.K_r:
				textdb.load_dbs(0)
			if e.type == pygame.KEYDOWN and e.key == pygame.K_q:
				self['TEST_sorti'] -= 1
				self['TEST_sorti'] %= 4
				self.dex_set_sort_both(self['TEST_sorti'], self['TEST_revsort'])
				self['listind'] = 0
				self.update_dex_listing()
			if e.type == pygame.KEYDOWN and e.key == pygame.K_w:
				self['TEST_sorti'] += 1
				self['TEST_sorti'] %= 4
				self.dex_set_sort_both(self['TEST_sorti'], self['TEST_revsort'])
				self['listind'] = 0
				self.update_dex_listing()
			if e.type == pygame.KEYDOWN and e.key == pygame.K_e:
				self['TEST_revsort'] = not self['TEST_revsort']
				self.dex_set_sort_both(self['TEST_sorti'], self['TEST_revsort'])
				self['listind'] = 0
				self.update_dex_listing()
			if e.type == pygame.KEYDOWN and e.key == pygame.K_s:
				self.dex_set_sort_both(self['TEST_sorti'], self['TEST_revsort'])
				self.dex_filter_by_mon_type(0, 0)
				self['listind'] = 0
				self.update_dex_listing()

			if e.type == pygame.KEYDOWN and e.key == pygame.K_ESCAPE:
				self.pop_scene()
				return 1

			if e.type == pygame.KEYDOWN and e.key == pygame.K_x:
				self['listind'] = 325
				self['formlist'] = None
				self['formind'] = 0
				self.update_dex_listing()
			self.dex_process_arrows(e)
					
			if e.type == pygame.MOUSEBUTTONDOWN:
				if e.button == 1:
					# left click
					for btn in self['buttons']:
						btn.action(self.mouse_pos)
			elif e.type == pygame.MOUSEBUTTONUP:
				if e.button == 1:
					self['holdingscroll'] = False

		self.win.blit(self['background'], (0, 0))

		if self['holdingscroll']:
			last_loc = self['listind']
			pos_y = self.mouse_pos[1] - 8
			t = (pos_y - 13) * (len(self['dexlist'][self['whichdex']]) - 1) // 317
			loc = min(max(t, 0), len(self['dexlist'][self['whichdex']]) - 1)
			self['listind'] = loc
			if loc != last_loc:
				self.dex_update_form_list()
				if self['formlist'] is None:
					self['formind'] = 0
				else:
					self['formind'] %= len(self['formlist'])
				self.update_dex_listing()

		# draw dex data
		dexdat = self['dexdata']
		if isinstance(dexdat.nums, str):
			flg = (False, False, False)
		else:
			flg = self.dex[int(dexdat.nums[1])][dexdat.nums[0]]
		if not flg[0]:
			self['formbox'].visible = False

		for button in self['buttons']:
			button.draw(self.win)
		self.text_boxes.draw(self.win)

		if isinstance(dexdat.nums, str):
			self.win.blit(GL.font.render_line(dexdat.nums, TXT_COL_DARK), (438, 15))
		else:
			self.win.blit(GL.font.get_dex_num_str(*dexdat.nums), (438, 15))

		if flg[2]:
			self['shinytoggle'].visible = True
			if self['showingshiny']:
				self['shinytoggle'].surf = self.gfx('dex_shiny_button_on')
			else:
				self['shinytoggle'].surf = self.gfx('dex_shiny_button')
		else:
			self['shinytoggle'].visible = False
			self['showingshiny'] = False
		if flg[0]:
			# has seen
			self.win.blit(GL.font.render_line(dexdat.name, TXT_COL_DARK), (495, 15))
			if self['showingshiny']:
				spr = pygame.transform.scale(dexdat.spr_s, (128, 128))
			else:
				spr = pygame.transform.scale(dexdat.spr_n, (128, 128))
			self.win.blit(spr, (276, 20))
		else:
			self.win.blit(GL.font.render_line('-' * 10, TXT_COL_DARK), (495, 15))
		if flg[1]:
			# has caught
			self.win.blit(GL.font.render_line(dexdat.spc, TXT_COL_DARK), (438, 31))
			for i, stati in enumerate((0, 1, 2, 4, 5, 3, 6)):
				if stati == 6:
					statv = sum(dexdat.stats)
				else:
					statv = dexdat.stats[stati]
				statn = (
					textdb.bs_stat_hp(),       textdb.bs_stat_attack(),
					textdb.bs_stat_defense(),  textdb.bs_stat_speed(),
					textdb.bs_stat_spattack(), textdb.bs_stat_spdefense(),
					textdb.bs_stat_total())[stati]
				statr = dexdat.statrating[stati]
				y = 190 + i * 15
				statvsurf = GL.font.render_line(str(statv), TXT_COL_DARK)
				r = statvsurf.get_rect()
				r.y = y
				r.right = 360
				self.win.blit(GL.font.render_line(statn, TXT_COL_DARK), (270, y))
				self.win.blit(statvsurf, r.topleft)
				self.win.blit(GL.font.render_line(statr, TXT_COL_DARK), (382, y))
			for i,typ in enumerate(dexdat.typ):
				ico = self.get_type_icon(typ)
				self.win.blit(ico, (438 + 36 * i, 50))
			self.win.blit(self.gfx('dex_foorprintframe'), (578, 20))
			self.win.blit(pygame.transform.scale(dexdat.fprint, (32, 32)), (580, 22))
			abil1 = textdb.ability(dexdat.abils[0])[0]
			abil2 = textdb.ability(dexdat.abils[1])[0]
			self.win.blit(GL.font.render_line(textdb.bs_dex_abilitysign(), TXT_COL_DARK), (270, 302))
			self.win.blit(GL.font.render_text(f'{abil1}\n{abil2}', 16, TXT_COL_DARK), (316, 302))
			egggp_str = ' / '.join([textdb.egggroup(x)[0] for x in dexdat.egggp])
			self.win.blit(GL.font.render_line(egggp_str, TXT_COL_DARK), (270, 334))
			self.win.blit(self.gfx('dex_flags'), (438, 292))
			nams1 = (dexdat.name, dexdat.names[0], dexdat.names[1])
			nams2 = (dexdat.names[2], dexdat.names[3], dexdat.names[4])
			self.win.blit(GL.font.render_text('\n'.join(nams1), 16, TXT_COL_DARK), (458, 294))
			self.win.blit(GL.font.render_text('\n'.join(nams2), 16, TXT_COL_DARK), (550, 294))
			self.win.blit(GL.font.render_text(textdb.bs_dex_heightsign() + '\n' + textdb.bs_dex_weightsign(), 16, TXT_COL_DARK), (438, 68))
			self.win.blit(GL.font.render_line(f'{dexdat.htwt[0] / 10} m', TXT_COL_DARK), (483, 68))
			h_ft = dexdat.htwt[1] // 100
			h_in = dexdat.htwt[1] % 100
			self.win.blit(GL.font.render_line(f'{h_ft}\'{h_in:0>2}\'\'', TXT_COL_DARK), (540, 68))
			self.win.blit(GL.font.render_line(f'{dexdat.htwt[2] / 10} kg', TXT_COL_DARK), (483, 84))
			self.win.blit(GL.font.render_line(f'{dexdat.htwt[3] / 10} lbs.', TXT_COL_DARK), (540, 84))
			entrylins = GL.font.auto_line_text(dexdat.entry, 184)
			self.win.blit(GL.font.render_text(entrylins, 16, TXT_COL_DARK), (438, 126))
			if not self['formlist'] is None:
				if dexdat.index == 201:
					form_str = self['formlist'][self['formind']]
				else:
					form_ind = self['formlist'][self['formind']][1]
					form_name = textdb.monform(form_ind)[1]
					form_str = textdb.bs_dex_formsign().format(form_name)
				self.win.blit(GL.font.render_line(form_str, TXT_COL_DARK), (302, 166))

		# draw list data
		sel_frame_y = 13 + (self['listind'] - self['listmin']) * 16
		self.win.blit(self.gfx('dex_sel_frame'), (54, sel_frame_y))
		for i,entr in enumerate(self['listing']):
			nam, num, flg = entr
			y = 15 + i * 16
			self.win.blit(GL.font.get_dex_num_str(*num), (78, y))
			if flg[0] and flg[1]:
				self.win.blit(self.gfx('dex_own_icon'), (62, y))
			x = 124
			if num[1]:
				x += GL.font.cw('★')
			self.win.blit(GL.font.render_line(nam, TXT_COL_DARK), (x, y))

		# ~ self.win.blit(GL.font.render_line(str(self['dexdata'].index), TXT_COL_DARK), (276, 20))
		for i in range(1,3):
			pygame.draw.line(self.win, pygame.Color(184, 152, 88), (207+i, 13), (207+i, 346))
		scroll_x = 203
		if self['listind'] == 0:
			scroll_y = 13
		else:
			scroll_y = (self['listind'] - 1) * 317 // (len(self['dexlist'][self['whichdex']]) - 2) + 14
		self.win.blit(self.gfx('dex_scroll_indicator'), (scroll_x, scroll_y))

		return 1

	def change_game_data(self, key, delta, bound=None):
		self[key] += delta
		if not bound is None:
			if isinstance(bound, int):
				self[key] %= bound
			else:
				self[key] = max(min(self[key], bound[1]), bound[0])

	def take_screenshot(self):
		filelist = [f for f in os.listdir('screenshot') if re.match(r'pic[0-9]+\.png', f)]
		nexti = 0
		for f in filelist:
			newi = int(re.match(r'pic([0-9]+)\.png', f).groups()[0])
			nexti = max(nexti, newi)
		fnout = f'screenshot/pic{nexti + 1}.png'
		pygame.image.save(self.win, fnout)

	def toggle_fullscreen(self):
		GL.fullscreen = not GL.fullscreen
		self.init_view()

	def mainloop_options(self):
		if self.scene_init:
			bg_tile = self.gfx('options_bg_tile')
			self['background'] = self.make_background_surf(bg_tile)
			self['background_tile_size'] = bg_tile.get_rect().size
			self['background_offset'] = [0, 0]
			button_list = []
			button_list.append( Button(4, 4, self.gfx('box_button_back'), lambda: self.pop_scene()) )
			button_list.append( Button(79, 55, self.gfx('arrow_button_left'), lambda: GL.change_text_speed(-1)) )
			button_list.append( Button(89 + 8 * len(TEXT_SPEEDS), 55, self.gfx('arrow_button_right'), lambda: GL.change_text_speed(1)) )
			button_list.append( Button(14, 118, self.gfx('arrow_button_up'), lambda: self.change_game_data('frame_row', -1, 8)) )
			button_list.append( Button(14, 138, self.gfx('arrow_button_down'), lambda: self.change_game_data('frame_row', 1, 8)) )
			button_list.append( Button(36, 116, (32, 32), lambda: GL.set_window_frame(0, self.current_data)) )
			button_list.append( Button(76, 116, (32, 32), lambda: GL.set_window_frame(1, self.current_data)) )
			button_list.append( Button(116, 116, (32, 32), lambda: GL.set_window_frame(2, self.current_data)) )
			button_list.append( Button(156, 116, (32, 32), lambda: GL.set_window_frame(3, self.current_data)) )
			button_list.append( Button(196, 116, (32, 32), lambda: GL.set_window_frame(4, self.current_data)) )
			button_list.append( Button(245, 53, self.gfx('options_checkbox_off'), lambda: self.toggle_fullscreen()) )
			self['buttons'] = button_list
			self.text_boxes.add(TextBox, 4, 40, 21, 5, textdb.bs_options_textspeed(), (0, 6))
			self.text_boxes.add(TextBox, 4, 88, 33, 9, textdb.bs_options_windowframe(), (0, 4))
			self.text_boxes.add(TextBox, 180, 40, 11, 5, textdb.bs_options_fullscreen(), (0, 6))
			self.text_boxes.write_all()
			self['example_text'] = TextBox(276, 40, 16, 15, textdb.bs_options_teststring())
			self.text_boxes.add(self['example_text'])
			self['frame_row'] = GL.window_frame // 5
			self['redraw_delay'] = 0
			self.scene_init = False

		for e in pygame.event.get():
			if e.type == pygame.QUIT:
				return 0

			self.handle_global_keys(e)
			if self.input_locked: continue
			if e.type == pygame.KEYDOWN and e.key == pygame.K_ESCAPE:
				self.pop_scene()
				return 1

			# ~ self.update_temp_offset(e)

			if e.type == pygame.MOUSEBUTTONDOWN:
				if e.button == 1:
					# left click
					for btn in self['buttons']:
						btn.action(self.mouse_pos)
						self.text_boxes.update_frame()

		if GL.frame_ct & 1:
			for i in range(2):
				bg_size = self['background_tile_size'][i]
				bg_offset = self['background_offset'][i]
				bg_offset += (-1, 1)[i]
				while bg_offset > 0:
					bg_offset -= bg_size
				while bg_offset < -bg_size:
					bg_offset += bg_size
				self['background_offset'][i] = bg_offset

		if self['redraw_delay'] > 0:
			self['redraw_delay'] -= 1
			if self['redraw_delay'] == 0:
				self['example_text'].reset()
		else:
			if self['example_text'].done_printing:
				self['redraw_delay'] = 120

		self.win.blit(self['background'], self['background_offset'])

		self.text_boxes.update()
		self.text_boxes.draw(self.win)
		for btn in self['buttons']:
			btn.draw(self.win)
			# ~ self.win.blit(btn.surf, btn.rect.topleft)
		if GL.fullscreen:
			self.win.blit(self.gfx('options_checkbox_on'), (245, 53))
		for i in range(len(TEXT_SPEEDS)):
			if GL.text_speed_ind == i:
				tick = self.gfx('options_meter_tick_on')
			else:
				tick = self.gfx('options_meter_tick_off')
			self.win.blit(tick, (90 + i * 8, 55))
		self.win.blit(self.gfx('options_frame_select'), (32, 112), pygame.Rect((0, self['frame_row'] * 40), (200, 40)))
		if GL.window_frame // 5 == self['frame_row']:
			cur_x = 32 + (GL.window_frame % 5) * 40
			self.win.blit(self.gfx('options_frame_cursor'), (cur_x, 112))
		save_options()

	def make_background_surf(self, tile):
		w, h = tile.get_rect().size
		num_t_x = WIN_SIZE[0] // w + 1
		if WIN_SIZE[0] % w != 0:
			num_t_x += 1
		num_t_y = WIN_SIZE[1] // h + 1
		if WIN_SIZE[1] % h != 0:
			num_t_y += 1
		surf = pygame.Surface((num_t_x * w, num_t_y * h))
		for y in range(num_t_y):
			for x in range(num_t_x):
				surf.blit(tile, (x * w, y * h))
		return surf

	def box_open_need_to_save_box(self):
		if not self['cur_sel_mon'] is None:
			return
		if self['need_to_save_box']:
			return
		if not self['changes_to_save']:
			self.pop_scene()
			return
		self['need_to_save_box'] = True
		self['cur_hover_mon'] = None
		opt_box = OptionBox(0, 0, 22, 9, textdb.bs_bank_unsaveddata(), (
			(self.gfx('button_yes'), (8, 40)),
			(self.gfx('button_no'), (64, 40)),
			(self.gfx('button_cancel'), (120, 40)),
		), (
			lambda: (self.deffered_save_and_pop_scene() or 1),
			lambda: (self.pop_scene() or 1),
			lambda: True,
		))
		opt_box.move_to_center()
		self.text_boxes.add(opt_box)

	def box_find_next_button(self, cur_btn_i, direc):
		cur_btn = self['buttons'][cur_btn_i]
		cur_pos = cur_btn.rect.center
		if direc[0] != 0:
			axis_rect = pygame.Rect(0, cur_pos[1], WIN_SIZE[0], 1)
		else:
			axis_rect = pygame.Rect(cur_pos[0], 0, 1, WIN_SIZE[1])
		btn_list = []
		for i,btn in enumerate(self['buttons']):
			if i == 0: continue
			if i == cur_btn_i: continue
			if btn.rect.colliderect(axis_rect):
				btn_list.append((i, btn))
		if len(btn_list) == 0:
			return cur_btn_i
		while True:
			cur_pos = ((cur_pos[0] + direc[0]) % WIN_SIZE[0], (cur_pos[1] + direc[1]) % WIN_SIZE[1])
			for i,btn in btn_list:
				if btn.rect.collidepoint(cur_pos):
					return i

	def box_mon_button_action(self, b, i):
		if b == 0:
			tgt_box = self['box_bank'][0]
		else:
			tgt_box = self['box_save'][0]

		if self['cur_sel_mon'] is None:
			# pick up pokemon
			if tgt_box[i] is None:
				return
			self['cur_sel_mon'] = poke.open_mon(tgt_box[i])
			tgt_box[i] = None
			self['changes_to_save'] = True
		else:
			# put down pokemon
			# ~ if not tgt_box[i] is None:
				# ~ return
			store_mon = poke.open_mon(tgt_box[i])
			tgt_box[i] = poke.open_mon(self['cur_sel_mon'])
			self['cur_sel_mon'] = store_mon
			self['changes_to_save'] = True

	def box_nav_left_right(self, b, delta):
		if b == 0:
			self['cur_box_bank'] = (self['cur_box_bank'] + delta) % len(self['bank_box_ind_list'])
		else:
			self['cur_box_save'] = (self['cur_box_save'] + delta) % len(self['save_box_ind_list'])
		self.update_boxes()

	def box_test_box_filter(self, dat, param):
		pass

	def box_filter_box_list(self, b, param):
		pass

	def box_filter_remove(self, b):
		if b == 0:
			lst = tuple(range(0, len(self.data)))
		else:
			lst = tuple(range(0, len(self['loaded_save'].box_data[0])))
		return lst

	def box_swap_contents(self):
		if len(self['box_bank'][0]) != len(self['box_save'][0]):
			# bank is 30, save is 20
			# check that the side spots are empty
			# if not, gtfo
			for i in (0, 5, 6, 11, 12, 17, 18, 23, 24, 29):
				if not self['box_bank'][0][i] is None:
					return
		self['changes_to_save'] = True
		self['swap_anim'] = 30
		self['hoverbox'] = None
		self.input_locked += 1
		for y in range(5):
			for x in range(6):
				for j,bx in enumerate((self['box_bank'][0], self['box_save'][0])):
					if len(bx) == 20:
						if x == 0 or x == 5: continue
						i = y * 4 + x - 1
					else:
						i = y * 6 + x
					mon = poke.open_mon(bx[i])
					if mon is None: continue
					if mon.is_egg:
						ico = gfx.load('i', 'egg')
					else:
						ico = gfx.load_mon(mon, 'i')
					xpos = 32 + 192 * j + x * 24
					ypos = 122 + y * 24
					prtc = MonSwapParticle(xpos, ypos, j*2-1, ico)
					self.add_particle(prtc)

		for y in range(5):
			for x in range(6):
				if len(self['box_save'][0]) == 20:
					if x == 0 or x == 5: continue
					i_sv = y * 4 + x - 1
				else:
					i_sv = y * 6 + x
				i_bx = y * 6 + x
				store = poke.open_mon(self['box_bank'][0][i_bx])
				self['box_bank'][0][i_bx] = poke.open_mon(self['box_save'][0][i_sv])
				self['box_save'][0][i_sv] = store

	def box_show_nyi_box(self):
		self.text_boxes.add( TextBox, 96, 16, 15, 6, textdb.bs_notimplemented() )

	def mainloop_box(self):
		if self.scene_init:
			if not self.queue_scene_change is None:
				return 1
			if self.filename_to_load is None:
				self.pop_scene()
				return 1
			self.data, self.dex = self.open_bank_save()
			self.custom_cursor = (self.gfx('box_cursor'), (-6, -24))

			self['loaded_save'] = None
			self['box_bank'] = None
			self['box_save'] = None
			self['cur_box_bank'] = 0
			self['cur_box_save'] = 0
			self['box_save_ct'] = 1
			self['cur_sel_mon'] = None
			self['cur_hover_mon'] = None

			self['changes_to_save'] = False
			self['need_to_save_box'] = False

			try:
				save_file = save.load_save(self.filename_to_load)
			except:
				self.pop_scene()
				return 1
			self['loaded_save'] = save_file

			self['bank_box_ind_list'] = self.box_filter_remove(0)
			self['save_box_ind_list'] = self.box_filter_remove(1)

			self.update_boxes()

			bg_tile = self.gfx('box_bg_tile')
			self['background'] = self.make_background_surf(bg_tile)
			self['background_tile_size'] = bg_tile.get_rect().size
			self['background_offset'] = [0, 0]
			self['buttons'] = []

			self['cursor_pos'] = 5

			self['buttons'].append( Button(4, 4, self.gfx('box_button_back'), lambda: self.box_open_need_to_save_box(), 'Quit to menu') )
			self['buttons'].append( Button(56, 4, self.gfx('box_save_button'), lambda: self.save(), 'Save data') )

			self['buttons'].append( Button(46, 87, self.gfx('box_button_paper'), lambda: self.box_show_nyi_box(), 'Change wallpaper') )
			self['buttons'].append( Button(76, 87, self.gfx('box_jump'), lambda: None, 'Jump to box') )
			self['buttons'].append( Button(140, 87, self.gfx('box_button_name'), lambda: self.box_show_nyi_box(), 'Change name') )
			self['buttons'].append( Button(32, 105, self.gfx('box_button_nav_left'), lambda: self.box_nav_left_right(0, -1)) )
			self['buttons'].append( Button(46, 105, (124, 22), lambda: None) )
			self['buttons'].append( Button(172, 105, self.gfx('box_button_nav_right'), lambda: self.box_nav_left_right(0, 1)) )

			self['buttons'].append( Button(238, 87, self.gfx('box_button_paper'), lambda: self.box_show_nyi_box(), 'Change wallpaper') )
			self['buttons'].append( Button(268, 87, self.gfx('box_jump'), lambda: None, 'Jump to box') )
			self['buttons'].append( Button(332, 87, self.gfx('box_button_name'), lambda: self.box_show_nyi_box(), 'Change name') )
			self['buttons'].append( Button(224, 105, self.gfx('box_button_nav_left'), lambda: self.box_nav_left_right(1, -1)) )
			self['buttons'].append( Button(238, 105, (124, 22), lambda: None) )
			self['buttons'].append( Button(364, 105, self.gfx('box_button_nav_right'), lambda: self.box_nav_left_right(1, 1)) )

			self['buttons'].append( Button(192, 178, self.gfx('box_button_swap'), lambda: self.box_swap_contents(), 'Swap box contents') )

			self['buttons'].append( Button(28, 304, self.gfx('box_button_filter'), lambda: self.box_show_nyi_box(), 'Filter boxes') )
			self['buttons'].append( Button(84, 304, self.gfx('box_button_groups'), lambda: self.box_show_nyi_box(), 'Manage box groups') )
			self['buttons'].append( Button(140, 304, self.gfx('box_button_sort'), lambda: self.box_show_nyi_box(), 'Sort boxes') )

			slot_i = 0
			for y in range(5):
				for x in range(6):
					b_x = 36 + x * 24
					b_y = 130 + y * 24
					btn = Button(b_x, b_y, (24, 24), lambda x=slot_i: self.box_mon_button_action(0, x))
					btn.tag = ('mon', 0, slot_i)
					self['buttons'].append( btn )
					slot_i += 1

			if len(self['loaded_save'].box_data[0][0]) == 20:
				minx = 1
				maxx = 5
			else:
				minx = 0
				maxx = 6
			slot_i = 0
			for y in range(5):
				for x in range(minx,maxx):
					b_x = 228 + x * 24
					b_y = 130 + y * 24
					btn = Button(b_x, b_y, (24, 24), lambda x=slot_i: self.box_mon_button_action(1, x))
					btn.tag = ('mon', 1, slot_i)
					self['buttons'].append( btn )
					slot_i += 1

			self['swap_anim'] = 0

			self.scene_init = False

		for e in pygame.event.get():
			if e.type == pygame.QUIT:
				return 0

			self.handle_global_keys(e)
			if self.input_locked: continue

			# ~ self.update_temp_offset(e)

			if e.type == pygame.KEYDOWN:
				if e.key == pygame.K_ESCAPE:
					self.box_open_need_to_save_box()
				elif e.key in (pygame.K_KP2, pygame.K_KP4, pygame.K_KP6, pygame.K_KP8):
					if e.key == pygame.K_KP2: direc = ( 0,  1)
					if e.key == pygame.K_KP4: direc = (-1,  0)
					if e.key == pygame.K_KP6: direc = ( 1,  0)
					if e.key == pygame.K_KP8: direc = ( 0, -1)
					cur_i = self['cursor_pos']
					new_i = self.box_find_next_button(cur_i, direc)
					self['cursor_pos'] = new_i
			if e.type == pygame.MOUSEBUTTONDOWN:
				if e.button == 1:
					if self['need_to_save_box']:
						if self.text_boxes.action(self.mouse_pos):
							self['need_to_save_box'] = False
							self.text_boxes.pop()
					elif self.text_boxes.any():
						self.text_boxes.do_click_thru()
					else:
						for i,btn in enumerate(self['buttons']):
							btn.action(self.mouse_pos)
			if e.type == pygame.MOUSEMOTION:
				hit_mon = False
				if self['need_to_save_box'] == False:
					for btn in self['buttons']:
						if btn.hover(self.mouse_pos):
							if not btn.tag is None:
								_, whc, ind = btn.tag
								if whc == 1:
									tgt_sav = self['box_save']
								else:
									tgt_sav = self['box_bank']
								tgt_mon = tgt_sav[0][ind]
								self['cur_hover_mon'] = tgt_mon
								hit_mon = True
								break
							if not btn.hover_text is None:
								self['hoverbox'] = (make_hover_box(btn.hover_text), self.mouse_pos)
								break
					else:
						self['hoverbox'] = None
				if not hit_mon:
					self['cur_hover_mon'] = None

			continue
			'''
			if e.type == pygame.KEYDOWN:
				if not self.file_dialog_dict is None: continue
				if e.key in (pygame.K_UP, pygame.K_LEFT, pygame.K_DOWN, pygame.K_RIGHT):
					delta = {pygame.K_UP:(0,-1),pygame.K_LEFT:(-1,0),pygame.K_DOWN:(0,1),pygame.K_RIGHT:(1,0)}[e.key]
					self.temp_offset[0] += delta[0]
					self.temp_offset[1] += delta[1]
					print(self.temp_offset)
				if e.key == pygame.K_ESCAPE:
					self.save()
					self.pop_scene()
				elif e.key == pygame.K_o:
					self.input_locked += 1
					self.file_dialog_dict = ask_file()
				elif e.key == pygame.K_k:
					save.print_save_profile(self['loaded_save'])
				elif e.key == pygame.K_l: # DEBUG
					if self['loaded_save'] is None: continue
					save_box_1 = self['loaded_save'].box_data[0][self['cur_box_save']]
					my_box_1 = self.data[self['cur_box_bank']][0]
					self.data[self['cur_box_bank']][0] = save_box_1
					self['loaded_save'].box_data[0][self['cur_box_save']] = my_box_1
					self.update_boxes()
				elif e.key == pygame.K_j:
					if self['loaded_save'] is None: continue
					if self['cur_sel_mon'] is None: continue
					# if moving from bank to save, check if mon is valid
					if self['cur_sel_mon_pos'][0] == 0:
						if not self['loaded_save'].check_mon_valid(self['cur_sel_mon']):
							continue
						other_box = self['loaded_save'].box_data[0][self['cur_box_save']]
					else:
						other_box = self.data[self['cur_box_bank']][0]
					try:
						other_ind = other_box.index(None)
					except:
						other_ind = None
					if other_ind is None: continue
					if self['cur_sel_mon_pos'][0] == 0:
						self.data[self['cur_sel_mon_pos'][1]][0][self['cur_sel_mon_pos'][2]] = None
						self['loaded_save'].box_data[0][self['cur_box_save']][other_ind] = self['cur_sel_mon']
						self['cur_sel_mon_pos'] = (1, self['cur_box_save'], other_ind)
					else:
						self['loaded_save'].box_data[0][self['cur_sel_mon_pos'][1]][self['cur_sel_mon_pos'][2]] = None
						self.data[self['cur_box_bank']][0][other_ind] = self['cur_sel_mon']
						self['cur_sel_mon_pos'] = (0, self['cur_box_bank'], other_ind)
				elif e.key == pygame.K_m:
					if self['loaded_save'] is None: continue
					if self['cur_sel_mon'] is None: continue
					# if moving from bank to save, check if mon is valid
					if self['cur_sel_mon_pos'][0] == 0:
						if not self['loaded_save'].check_mon_valid(self['cur_sel_mon']):
							continue
						other_box = self['loaded_save'].box_data[0][self['cur_box_save']]
					else:
						other_box = self.data[self['cur_box_bank']][0]
					try:
						other_ind = other_box.index(None)
					except:
						other_ind = None
					if other_ind is None: continue
					if self['cur_sel_mon_pos'][0] == 0:
						# ~ self.data[self['cur_sel_mon_pos'][1]][0][self['cur_sel_mon_pos'][2]] = None
						self['loaded_save'].box_data[0][self['cur_box_save']][other_ind] = self['cur_sel_mon']
						# ~ self['cur_sel_mon_pos'] = (1, self['cur_box_save'], other_ind)
					else:
						# ~ self['loaded_save'].box_data[0][self['cur_sel_mon_pos'][1]][self['cur_sel_mon_pos'][2]] = None
						self.data[self['cur_box_bank']][0][other_ind] = self['cur_sel_mon']
						# ~ self['cur_sel_mon_pos'] = (0, self['cur_box_bank'], other_ind)
				elif e.key == pygame.K_q:
					self['cur_box_bank'] = (self['cur_box_bank'] - 1) % len(self.data)
					self.update_boxes()
				elif e.key == pygame.K_w:
					self['cur_box_bank'] = (self['cur_box_bank'] + 1) % len(self.data)
					self.update_boxes()
				elif e.key == pygame.K_a:
					self['cur_box_bank'] = (self['cur_box_bank'] - 20) % len(self.data)
					self.update_boxes()
				elif e.key == pygame.K_s:
					self['cur_box_bank'] = (self['cur_box_bank'] + 20) % len(self.data)
					self.update_boxes()
				elif e.key == pygame.K_e:
					self['cur_box_save'] = (self['cur_box_save'] - 1) % self['box_save_ct']
					self.update_boxes()
				elif e.key == pygame.K_r:
					self['cur_box_save'] = (self['cur_box_save'] + 1) % self['box_save_ct']
					self.update_boxes()
				elif e.key == pygame.K_d:
					GL.window_frame += 1
					GL.window_frame %= 40
				elif e.key == pygame.K_c:
					GL.window_frame -= 1
					GL.window_frame %= 40
					# ~ mon = self['cur_sel_mon']
					# ~ mon.held_item += 1
					# ~ while textdb.item(mon.held_item)[0] == '????????':
						# ~ mon.held_item += 1
					# ~ if mon.held_item >= len(textdb.DB_ITEM):
						# ~ mon.held_item = 0
				# ~ elif e.key == pygame.K_c:
					# ~ mon = self['cur_sel_mon']
					# ~ mon.held_item -= 1
					# ~ while textdb.item(mon.held_item)[0] == '????????':
						# ~ mon.held_item -= 1
					# ~ if mon.held_item <= 0:
						# ~ mon.held_item = len(textdb.DB_ITEM) - 1
				elif e.key == pygame.K_g:
					if len(self.text_boxes.lst):
						x, y = self.text_boxes.lst[-1].rect.topleft
						x += 12
						y += 30
					else:
						x = 0
						y = 0
					self.text_boxes.add(TextBox, x, y, 50, 40, 'Testing text box stuff here. Should be a long, but good, string! Let\'s... repeat it a couple of times, perhaps. :D ' * 10)
				elif e.key == pygame.K_BACKSPACE:
					self.text_boxes.pop()
			elif e.type == pygame.MOUSEBUTTONDOWN:
				if e.button == 1:
					# left click
					if self.text_boxes.any():
						if self.text_boxes.action(epos):
							self.text_boxes.pop()
					else:
						for i,btn in enumerate(self['buttons']):
							if i == 0:
								if btn.hover(epos):
									opt_box = OptionBox(0, 0, 22, 9, textdb.bs_bank_unsaveddata(), (
										(self.gfx('button_yes'), (8, 40)),
										(self.gfx('button_no'), (64, 40)),
										(self.gfx('button_cancel'), (120, 40)),
									), (
										lambda: (self.deffered_save_and_pop_scene() or 1),
										lambda: (self.pop_scene() or 1),
										lambda: True,
									))
									opt_box.move_to_center()
									self.text_boxes.add(opt_box)
							else:
								btn.action(epos)

						target_mon = self['box_bank'].click(epos)
						if target_mon is None:
							if not self['box_save'] is None:
								target_mon = self['box_save'].click(epos)
								if not target_mon is None:
									target_mon = (*target_mon, self['cur_box_save'], 1)
						else:
							target_mon = (*target_mon, self['cur_box_bank'], 0)
						if not target_mon is None:
							self['cur_sel_mon_pos'] = (target_mon[3], target_mon[2], target_mon[1])
							self['cur_sel_mon'] = target_mon[0]
				elif e.button == 2:
					# middle click
					# ~ print(evpos)
					self.temp_offset[0] = epos[0]
					self.temp_offset[1] = epos[1]
					print(self.temp_offset)
					# ~ self.add_particle(DVDScreensaverParticle(50 + random.randint(-3, 3) * 2, 50 + random.randint(-3, 3) * 2))
'''

		# ~ for _ in range(3):
			# ~ self.add_particle(TestParticle(*self.mouse_pos))
		if GL.frame_ct & 1:
			for i in range(2):
				bg_size = self['background_tile_size'][i]
				bg_offset = self['background_offset'][i]
				bg_offset += (-1, 1)[i]
				while bg_offset > 0:
					bg_offset -= bg_size
				while bg_offset < -bg_size:
					bg_offset += bg_size
				self['background_offset'][i] = bg_offset

		self.win.blit(self['background'], self['background_offset'])

		if self['swap_anim'] > 0:
			self['swap_anim'] -= 1
			if self['swap_anim'] == 0:
				self.input_locked -= 1
		if not self['box_bank'] is None:
			self.win.blit(self.get_wallpaper(self['box_bank'][2]), (BANK_BOX_LOCATION[0], BANK_BOX_LOCATION[1]))
			self.win.blit(self.get_nameplate(self['box_bank'][2]), (BANK_BOX_LOCATION[0] + 16, BANK_BOX_LOCATION[1] - 31))
			if self['swap_anim'] == 0:
				for y in range(5):
					for x in range(6):
						if len(self['box_bank'][0]) == 20:
							if x == 0 or x == 5: continue
							i = y * 4 + x - 1
						else:
							i = y * 6 + x
						mon = poke.open_mon(self['box_bank'][0][i])
						if mon is None: continue
						if mon.is_egg:
							ico = gfx.load('i', 'egg')
						else:
							ico = gfx.load_mon(mon, 'i')
						self.win.blit(ico, (BANK_BOX_LOCATION[0] + x * 24 + 2, BANK_BOX_LOCATION[1] + y * 24 - 14))
			nm = GL.font.render_line(self['box_bank'][1], TXT_COL_LIGHT)
			nmr = nm.get_rect().move(0, BANK_BOX_LOCATION[1] - 26)
			nmr.centerx = BANK_BOX_LOCATION[0] + 16 + 124 // 2
			self.win.blit(nm, nmr.topleft)
		else:
			self.win.blit(self.get_wallpaper(-1), (BANK_BOX_LOCATION[0], BANK_BOX_LOCATION[1]))
			self.win.blit(self.get_nameplate(-1), (BANK_BOX_LOCATION[0] + 16, BANK_BOX_LOCATION[1] - 31))
		if not self['box_save'] is None:
			self.win.blit(self.get_wallpaper(self['box_save'][2]), (SAVE_BOX_LOCATION[0], SAVE_BOX_LOCATION[1]))
			self.win.blit(self.get_nameplate(self['box_save'][2]), (SAVE_BOX_LOCATION[0] + 16, SAVE_BOX_LOCATION[1] - 31))
			if self['swap_anim'] == 0:
				for y in range(5):
					for x in range(6):
						if len(self['box_save'][0]) == 20:
							if x == 0 or x == 5: continue
							i = y * 4 + x - 1
						else:
							i = y * 6 + x
						mon = poke.open_mon(self['box_save'][0][i])
						if mon is None: continue
						if mon.is_egg:
							ico = gfx.load('i', 'egg')
						else:
							ico = gfx.load_mon(mon, 'i')
						self.win.blit(ico, (SAVE_BOX_LOCATION[0] + x * 24 + 2, SAVE_BOX_LOCATION[1] + y * 24 - 14))
			nm = GL.font.render_line(self['box_save'][1], TXT_COL_LIGHT)
			nmr = nm.get_rect().move(0, SAVE_BOX_LOCATION[1] - 26)
			nmr.centerx = SAVE_BOX_LOCATION[0] + 16 + 124 // 2
			self.win.blit(nm, nmr.topleft)
		else:
			self.win.blit(self.get_wallpaper(-1), (SAVE_BOX_LOCATION[0], SAVE_BOX_LOCATION[1]))
			self.win.blit(self.get_nameplate(-1), (SAVE_BOX_LOCATION[0] + 16, SAVE_BOX_LOCATION[1] - 31))

		self.win.blit(self.gfx('status_frame'), (400, 0))

		if not self['cur_sel_mon'] is None:
			self['cur_hover_mon'] = self['cur_sel_mon']
		mon = poke.open_mon(self['cur_hover_mon'])
		if not mon is None:
			if mon.is_egg:
				spr = gfx.load('n', 'egg')
			else:
				if mon.shiny and GL.use_shiny_particles:
					spr = gfx.load_mon(mon, 's')
					self.win.blit(self.gfx('status_frame_shiny'), (400, 0))
					if not (mon.species == 130 and mon.met_location == 298 and mon.met_lv == 30):
						if random.random() < 0.1:
							prtx = random.randint(440, 480)
							prty = random.randint(20, 30)
							self.add_particle(ShinyParticle(prtx, prty))
				else:
					spr = gfx.load_mon(mon, 'n')

			self.win.blit(spr, (428, 17))
			self.win.blit(GL.font.render_line(mon.nickname, TXT_COL_LIGHT), (440, 3))
			if not mon.is_egg:
				bas = pokedb.BASE_STATS[mon.species]
				if bas is None:
					self.win.blit(GL.font.render_line('??????????', TXT_COL_DARK), (567, 20))
				else:
					self.win.blit(GL.font.render_line(bas.name, TXT_COL_DARK), (567, 20))
					self.win.blit(GL.font.render_line(str(mon.level), TXT_COL_LIGHT), (415, 3))
					self.win.blit(self.get_type_icon(bas.typ[0]), (567, 35))
					if bas.typ[0] != bas.typ[1]:
						self.win.blit(self.get_type_icon(bas.typ[1]), (603, 35))
					dex_gp, dex_num = bas.dex
					if dex_gp == 1:
						num_str = f'★{dex_num:0>3}'
					else:
						num_str = f'{dex_num:0>3}'
					self.win.blit(GL.font.render_line(num_str, TXT_COL_DARK), (567, 5))
					gnd = mon.gender
					if gnd == 'male':
						self.win.blit(GL.font.render_line('♂', TXT_COL_BLUE), (505, 3))
					elif gnd == 'female':
						self.win.blit(GL.font.render_line('♀', TXT_COL_RED), (505, 3))
					self.win.blit(GL.font.render_line(mon.ot_name, TXT_COL_DARK), (567, 50))
					self.win.blit(GL.font.render_line(f'{mon.tid:0>5}', TXT_COL_DARK), (567, 65))
					ntr = textdb.nature(mon.pid % 25)[0]
					self.win.blit(GL.font.render_line(f'{ntr} nature.', TXT_COL_DARK), (408, 100))
					origins_lins = GL.font.auto_line_text(mon.get_origins_string(), 228)
					self.win.blit(GL.font.render_text(origins_lins, 14, TXT_COL_DARK), (408, 114))
					stats = mon.stats
					for _y,stati in zip((0, 14, 27, 40, 53, 66),(0, 1, 2, 4, 5, 3)):
						if stati == 0:
							stat_str = GL.font.render_line(f'{stats[stati]}/{stats[stati]}', TXT_COL_DARK)
						else:
							stat_str = GL.font.render_line(str(stats[stati]), TXT_COL_DARK)
						x = 637 - stat_str.get_rect().w
						y = _y + 147
						self.win.blit(stat_str, (x, y))
					exp_str = GL.font.render_line(str(mon.exp), TXT_COL_DARK)
					self.win.blit(exp_str, (637 - exp_str.get_rect().w, 226))
					exp_to_nxt_lvl = pokedb.get_exp_at_level(mon.level + 1, pokedb.BASE_STATS[mon.species].exp_gp_id) - mon.exp
					nxt_lvl_exp_str = GL.font.render_line(str(exp_to_nxt_lvl), TXT_COL_DARK)
					self.win.blit(nxt_lvl_exp_str, (637 - nxt_lvl_exp_str.get_rect().w, 239))
					abil_name, abil_desc = textdb.ability(mon.ability)
					self.win.blit(GL.font.render_line(abil_name, TXT_COL_DARK), (474, 252))
					self.win.blit(GL.font.render_line(abil_desc, TXT_COL_DARK), (410, 264))
					for i,mov in enumerate(mon.moves):
						mov_dat = textdb.move(mov)
						if mov != 0:
							typ_ico = self.get_type_icon(int(mov_dat[2]))
							self.win.blit(typ_ico, (523, 283 + i * 18))
						self.win.blit(GL.font.render_line(mov_dat[0], TXT_COL_DARK), (557, 286 + i * 18))
					self.win.blit(self.get_ball_icon(pokedb.CAUGHT_BALL.index(mon.ball)), (500, 66))
					itm_name = textdb.item(mon.held_item)[0]
					self.win.blit(GL.font.render_line(itm_name, TXT_COL_DARK), (555, 80))
					mark = mon.marking
					for i in range(4):
						if mark & (1 << i):
							self.win.blit(self.get_mark_icon(i), (404 + i * 8, 71))
						elif mark:
							self.win.blit(self.get_mark_icon(i + 4), (404 + i * 8, 71))
					if mon.pokerus:
						if mon.pokerus & 0xF:
							# active
							self.win.blit(self.gfx('box_pokerus_status'), (405, 18))
						else:
							# cured
							self.win.fill(pygame.Color(0, 0, 0), pygame.Rect(513, 75, 2, 2))

			# ~ debug_text = f'PID : {mon.pid:0>8X}\nTID : {mon.tid:0>4X}\nSID : {mon.sid:0>4X}\nIV : {mon.iv}'
			# ~ self.win.blit(GL.font.render_text(debug_text, 14, TXT_COL_LIGHT), (0, 220))

		for btn in self['buttons']:
			btn.draw(self.win)

		# ~ cur_btn = self['buttons'][self['cursor_pos']]
		# ~ cur_x = cur_btn.rect.centerx - 7
		# ~ cur_y = cur_btn.rect.y - 24
		# ~ self.win.blit(self.gfx('box_cursor'), (cur_x, cur_y))

		self.text_boxes.update()
		self.text_boxes.draw(self.win)

		if not self['hoverbox'] is None:
			x, y = self['hoverbox'][1]
			w, h = self['hoverbox'][0].get_rect().size
			self.win.blit(self['hoverbox'][0], (x + 8, y - h // 2))

		if not self['cur_sel_mon'] is None:
			mon = poke.open_mon(self['cur_sel_mon'])
			if mon.is_egg:
				ico = gfx.load('i', 'egg')
			else:
				ico = gfx.load_mon(mon, 'i')
			x, y = self.mouse_pos
			self.win.blit(ico, (x - 12, y - 18))

		# ~ pts = []
		# ~ for direc in ((0,1),(0,-1),(1,0),(-1,0)):
			# ~ col = {(0,1):(0,1,0),(0,-1):(1,0,0),(1,0):(0,0,1),(-1,0):(0,1,1)}[direc]
			# ~ cur_btn = self['cursor_pos']
			# ~ new_btn = self.box_find_next_button(cur_btn, direc)
			# ~ cur_c = self['buttons'][cur_btn].rect.center
			# ~ new_c = self['buttons'][new_btn].rect.center
			# ~ pts.append((cur_c, new_c, col))
		# ~ for p1, p2, col in pts:
			# ~ c = pygame.Color(191*col[0], 191*col[1], 191*col[2])
			# ~ pygame.draw.line(self.win, c, p1, p2, width=2)
		# ~ for _, p2, col in pts:
			# ~ c = pygame.Color(255*col[0], 255*col[1], 255*col[2])
			# ~ pygame.draw.circle(self.win, c, (p2[0]+1, p2[1]+1), radius=3)

		return 1

	def credits_add_item(self, surf, x, btn=None, overridey=None):
		if overridey is None:
			y = WIN_SIZE[1]
		else:
			y = overridey
		pos = [x, y]
		self['surfs'].append((surf, pos, btn))

	def credits_scroll(self, amt):
		for _,pos,btn in self['surfs']:
			if not btn is None and btn.tag == 'still': continue
			pos[1] -= amt

	def credits_get_column_x(self, c):
		if c == 0:
			return WIN_SIZE[0] // 2
		elif c == 1:
			return WIN_SIZE[0] // 3
		elif c == 2:
			return 2 * WIN_SIZE[0] // 3
		print(f'Unknown column {c}')
		return 0

	def credits_follow_link(self, lnk):
		self['scrolling'] = False
		webbrowser.open(lnk)

	def mainloop_credits(self):
		if self.scene_init:
			self['holddown'] = False
			self['scrolling'] = True
			self['cmdind'] = 0
			self['downdelay'] = 0
			self['donecommands'] = False

			self['surfs'] = []

			self.scene_init = False

		for e in pygame.event.get():

			if e.type == pygame.QUIT:
				return 0

			self.handle_global_keys(e)
			if self.input_locked: continue

			if e.type == pygame.KEYDOWN:
				if e.key == pygame.K_ESCAPE:
					self.pop_scene()
				elif e.key == pygame.K_DOWN:
					self['holddown'] = True
				elif e.key == pygame.K_SPACE:
					self['scrolling'] = not self['scrolling']
			elif e.type == pygame.KEYUP:
				if e.key == pygame.K_DOWN:
					self['holddown'] = False
			elif e.type == pygame.MOUSEBUTTONDOWN:
				if e.button == 1:
					for _,_,btn in self['surfs']:
						if btn is None: continue
						btn.action(self.mouse_pos)

		while self['downdelay'] == 0 and not self['donecommands']:
			# next cmds
			cur_cmd = cred.data[self['cmdind']]
			cmd, arg = cur_cmd[0], cur_cmd[1:]
			if cmd == 'logo':
				surf = self.gfx('logo')
				rct = surf.get_rect()
				rct.centerx = self.credits_get_column_x(0)
				self.credits_add_item(surf, rct.x)
			elif cmd == 'down':
				self['downdelay'] = arg[0] * 32
			elif cmd == 'lang':
				txt = textdb.bankstr(arg[0])[0]
				box = make_hover_box(txt)
				rct = box.get_rect()
				rct.centerx = self.credits_get_column_x(arg[1])
				self.credits_add_item(box, rct.x)
			elif cmd == 'text':
				txt = arg[0]
				box = make_hover_box(txt)
				rct = box.get_rect()
				rct.centerx = self.credits_get_column_x(arg[1])
				self.credits_add_item(box, rct.x)
			elif cmd == 'link':
				txt = arg[0]
				lnk = arg[1]
				box = make_hover_box(txt)
				rct = box.get_rect()
				rct.centerx = self.credits_get_column_x(arg[2])
				btn = Button(rct.x, 0, rct.size, lambda lnk=lnk: self.credits_follow_link(lnk))
				self.credits_add_item(box, rct.x, btn)
			elif cmd == 'back':
				txt = 'Back'
				box = make_hover_box(txt)
				rct = box.get_rect()
				rct.bottomright = WIN_SIZE
				rct.move_ip(-8, -8)
				btn = Button(rct.x, rct.y, rct.size, lambda: self.pop_scene())
				btn.tag = 'still'
				self.credits_add_item(box, rct.x, btn, overridey=rct.y)
			else:
				print(f'Unknown command "{cmd}"')
			self['cmdind'] += 1
			if self['cmdind'] >= len(cred.data):
				self['donecommands'] = True
		if self['downdelay']:
			if self['scrolling']:
				if self['holddown']:
					spd = min(3, self['downdelay'])
				else:
					spd = 1
				self.credits_scroll(spd)
				self['downdelay'] -= spd

		self.win.fill(pygame.Color(0, 191, 191))
		for i in range(len(self['surfs'])):
			s, p, b = self['surfs'][i]
			if p[1] < -s.get_rect().h:
				self['surfs'][i] = None
			else:
				self.win.blit(s, p)
				if not b is None:
					b.rect.topleft = p
		self['surfs'] = [x for x in self['surfs'] if not x is None]

		if not self['scrolling']:
			self.win.blit(self.gfx('pause_symbol'), (16, 16))

	def layouttest_load_data(self):
		with open('textlist.txt', 'r', encoding='utf8') as f:
			lins = f.read().split('\n')
		hit_sep_lin = False
		for l in lins:
			if l == '': continue
			if l == '~~~':
				hit_sep_lin = True
				continue

			if hit_sep_lin:
				a, b = l.split('@')
				pos = [int(x) for x in a.split(',')]
				t = b.replace('~', '\n')
				if not (t, pos) in self['temptexts']:
					self['temptexts'].append((t, pos))
			else:
				x, y, w, h = [int(x) for x in l.split(',')]
				self.text_boxes.add(TextFrame, x, y, w, h)

	def layouttest_save_data(self):
		with open('textlist.txt', 'w', encoding='utf8') as f:
			for bx in self.text_boxes.lst:
				x, y, w, h = bx.rect
				w //= 8
				h //= 8
				f.write(f'{x},{y},{w},{h}\n')
			f.write('~~~\n')
			for _tx,pos in self['temptexts']:
				tx = _tx.replace('\n', '~')
				f.write(f'{pos[0]},{pos[1]}@{tx}\n')

	def layouttest_move_tempbox(self, e):
		if self['tempbox'] is None:
			return
		if e.type == pygame.KEYDOWN:
			if e.key in (pygame.K_KP8, pygame.K_KP4, pygame.K_KP2, pygame.K_KP6):
				delta = {pygame.K_KP8:(0,-1),pygame.K_KP4:(-1,0),pygame.K_KP2:(0,1),pygame.K_KP6:(1,0)}[e.key]
				self['tempbox'][1][0] += delta[0]
				self['tempbox'][1][1] += delta[1]
				# ~ self['tempbox'][0].rect.topleft = self['tempbox'][1]
				self.layouttest_update_tempbox()
				print(self['tempbox'][0].rect.topleft)
			if e.key == pygame.K_KP5:
				self['tempbox'][1][0] -= self['tempbox'][1][0] % 8
				self['tempbox'][1][1] -= self['tempbox'][1][1] % 8
				self.layouttest_update_tempbox()
				print(self['tempbox'][0].rect.topleft)

	def layouttest_update_tempbox(self, pos = None):
		if pos is None:
			pos = self['lastpos']
		else:
			self['lastpos'] = pos
		if self['tempbox'] is None: return
		tempbox, opos = self['tempbox']
		x, y = pos
		ox, oy = opos
		w = max(abs(ox - x) // 8, 1)
		h = max(abs(oy - y) // 8, 1)
		if ox < x:
			tx = ox
		else:
			tx = ox - w * 8
		if oy < y:
			ty = oy
		else:
			ty = oy - h * 8
		tempbox.rect = pygame.Rect(tx, ty, w*8, h*8)
		tempbox.update_frame()

	def mainloop_layouttest(self):
		if self.scene_init:
			self['lastpos'] = (0, 0)
			self['temptexts'] = []
			self['tempbox'] = None
			self['temptext_val'] = None
			self.layouttest_load_data()
			self.scene_init = False

		for e in pygame.event.get():
			if e.type == pygame.QUIT:
				return 0

			self.handle_global_keys(e)
			if self.input_locked: continue
			if e.type == pygame.KEYDOWN and e.key == pygame.K_ESCAPE:
				self.pop_scene()
				return 1

			self.update_temp_offset(e)
			self.layouttest_move_tempbox(e)
			if e.type == pygame.KEYDOWN and e.key == pygame.K_BACKSPACE:
				self['cur_box_text'] = None
				self['tempbox'] = None
			if e.type == pygame.KEYDOWN and e.key == pygame.K_s:
				self.layouttest_save_data()
			if e.type == pygame.KEYDOWN and e.key == pygame.K_a:
				self.layouttest_load_data()
			if e.type == pygame.KEYDOWN and e.key == pygame.K_d:
				self['temptexts'] = []
				self.text_boxes.clear()

			if e.type == pygame.MOUSEMOTION:
				self.layouttest_update_tempbox(posscale(e.pos))
			if e.type == pygame.MOUSEBUTTONDOWN:
				self.layouttest_update_tempbox(posscale(e.pos))
				if e.button == 1:
					if self['cur_box_text'] is None:
						self['cur_box_text'] = pyperclip.paste().replace('\r', '')
					else:
						if not (self['cur_box_text'], self.temp_offset.copy()) in self['temptexts']:
							self['temptexts'].append((self['cur_box_text'], self.temp_offset.copy()))
							self['cur_box_text'] = None
				if e.button == 3:
					if self['tempbox'] is None:
						newbox = TextFrame(*posscale(e.pos), 1, 1)
						self['tempbox'] = (newbox, list(posscale(e.pos)))
					else:
						x, y, w, h = self['tempbox'][0].rect
						self['tempbox'] = None
						self.text_boxes.add(TextFrame, x, y, w // 8, h // 8)

		self.win.fill(pygame.Color(0, 0, 0))
		self.text_boxes.draw(self.win)
		if not self['tempbox'] is None:
			self['tempbox'][0].draw(self.win)
		for tx, pos in self['temptexts']:
			self.win.blit(GL.font.render_text(tx, 16, TXT_COL_DARK), pos)
		if not self['cur_box_text'] is None:
			self.win.blit(GL.font.render_text(self['cur_box_text'], 16, TXT_COL_DARK), self.temp_offset)

		return 1

	def mainloop(self):
		if self.scene == SCENE_NONE:
			return 0
		if self.scene == SCENE_TITLE:
			return self.mainloop_title()
		if self.scene == SCENE_BOX:
			return self.mainloop_box()
		if self.scene == SCENE_DEX:
			return self.mainloop_dex()
		if self.scene == SCENE_LOAD:
			return self.mainloop_load()
		if self.scene == SCENE_OPTIONS:
			return self.mainloop_options()
		if self.scene == SCENE_CREDITS:
			return self.mainloop_credits()

		if self.scene == SCENE_LAYOUTTEST:
			return self.mainloop_layouttest()

		return 0

if __name__ == '__main__':
	arg_p = argparse.ArgumentParser()
	arg_p.add_argument('--nosave', action='store_true')
	arg_p.add_argument('--startbox', action='store_true')
	arg_p.add_argument('--scale', type=int, default=1)
	args = arg_p.parse_args()

	WIN_SCALE = args.scale
	MOUSE_SCALE = WIN_SCALE
	update_view_size(WIN_SCALE)

	load_options()

	game = Game()
	game.run()
	game.save()
